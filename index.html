<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°é©¬è·³è·ƒæ¸¸æˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            gap: 20px;
        }

        #mainContainer {
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        #gameContainer {
            text-align: center;
            background: #000;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        #gameCanvas {
            border: 2px solid #333;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #228B22 100%);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #score {
            color: white;
            font-size: 24px;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #instructions {
            color: #ccc;
            font-size: 14px;
            margin-top: 10px;
        }

        .game-over {
            color: #ff4444;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #highScore {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 5px;
            border: 2px solid #FFD700;
        }

        #playerInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00FF00;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 5px;
            border: 2px solid #00FF00;
        }

        .offline {
            color: #FF4444 !important;
            border-color: #FF4444 !important;
        }

        #leaderboardSidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            color: white;
            font-family: 'Courier New', monospace;
            max-height: 500px;
            overflow-y: auto;
        }

        #leaderboardSidebar h3 {
            color: #FFD700;
            text-align: center;
            margin: 0 0 20px 0;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            border-bottom: 2px solid #FFD700;
            padding-bottom: 10px;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .leaderboard-entry.rank-1 {
            border-left-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }

        .leaderboard-entry.rank-2 {
            border-left-color: #C0C0C0;
            background: rgba(192, 192, 192, 0.2);
        }

        .leaderboard-entry.rank-3 {
            border-left-color: #CD7F32;
            background: rgba(205, 127, 50, 0.2);
        }

        .rank-number {
            font-weight: bold;
            font-size: 16px;
            min-width: 30px;
        }

        .rank-1 .rank-number { color: #FFD700; }
        .rank-2 .rank-number { color: #C0C0C0; }
        .rank-3 .rank-number { color: #CD7F32; }

        .player-name {
            flex: 1;
            margin: 0 10px;
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .player-score {
            font-weight: bold;
            color: #00FF00;
            font-size: 16px;
        }

        .medal {
            font-size: 18px;
            margin-right: 5px;
        }

        .no-data {
            text-align: center;
            color: #888;
            font-style: italic;
            padding: 20px;
        }

        .connection-status {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            font-size: 12px;
        }

        .connection-status.online {
            background: rgba(0, 255, 0, 0.2);
            color: #00FF00;
            border: 1px solid #00FF00;
        }

        .connection-status.offline {
            background: rgba(255, 68, 68, 0.2);
            color: #FF4444;
            border: 1px solid #FF4444;
        }

        .last-updated {
            text-align: center;
            font-size: 10px;
            color: #888;
            margin-top: 10px;
        }

        /* å…¶ä»–ç©å®¶æ¸¸æˆç”»é¢æ ·å¼ */
        #otherPlayersContainer {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #otherPlayersContainer h3 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        #otherPlayersDisplay {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }

        .player-game-view {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 300px;
            max-width: 400px;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }

        .player-name {
            font-weight: bold;
            color: #007bff;
            font-size: 16px;
        }

        .player-score {
            font-weight: bold;
            color: #28a745;
            font-size: 14px;
        }

        .mini-game-canvas {
            width: 100%;
            height: 150px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #228B22 100%);
            position: relative;
            overflow: hidden;
        }

        .player-stats {
            margin-top: 10px;
            font-size: 12px;
            color: #6c757d;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .no-players {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            padding: 40px;
        }

        .player-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
        }

        .status-online {
            background-color: #d4edda;
            color: #155724;
        }

        .status-offline {
            background-color: #f8d7da;
            color: #721c24;
        }

        /* å¯ç‚¹å‡»çš„æ’è¡Œæ¦œæ¡ç›®æ ·å¼ */
        .clickable-player {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .clickable-player:hover {
            background-color: #e3f2fd;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .view-game-hint {
            margin-left: 5px;
            font-size: 12px;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .clickable-player:hover .view-game-hint {
            opacity: 1;
        }

        /* é€‰ä¸­çš„ç©å®¶æ ·å¼ */
        .selected-player {
            background-color: #e8f5e8;
            border-left: 4px solid #28a745;
        }

        /* å•ä¸ªç©å®¶æ¸¸æˆç”»é¢æ˜¾ç¤º */
        .single-player-view {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .single-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .close-view-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .close-view-btn:hover {
            background-color: #c82333;
        }

        .large-game-canvas {
            width: 100%;
            height: 300px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 70%, #228B22 100%);
        }

        /* å¹³æ»‘æ§åˆ¶é¢æ¿æ ·å¼ */
        .smoothing-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 123, 255, 0.1);
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid rgba(0, 123, 255, 0.3);
        }

        .smoothing-controls label {
            font-size: 12px;
            font-weight: bold;
            color: #007bff;
            margin: 0;
        }

        .smoothing-controls input[type="range"] {
            width: 100px;
            height: 4px;
            background: #ddd;
            outline: none;
            border-radius: 2px;
        }

        .smoothing-controls input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
        }

        .smoothing-controls input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .smoothing-controls span {
            font-size: 12px;
            font-weight: bold;
            color: #007bff;
            min-width: 30px;
        }

        #toggleSmoothingBtn {
            background: #28a745;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #toggleSmoothingBtn:hover {
            background: #218838;
        }

        #toggleSmoothingBtn.disabled {
            background: #dc3545;
        }

        #toggleSmoothingBtn.disabled:hover {
            background: #c82333;
        }

        /* æ¸…é™¤æ•°æ®æŒ‰é’®æ ·å¼ */
        #clearDataContainer {
            text-align: center;
            margin: 30px auto;
            padding: 20px;
            max-width: 1200px;
        }

        #clearAllDataBtn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #clearAllDataBtn:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        #clearAllDataBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>

<body>
    <div id="mainContainer">
        <div id="gameContainer">
            <div id="playerInfo">ç©å®¶: è¿æ¥ä¸­... | çŠ¶æ€: ç¦»çº¿</div>
            <div id="highScore">æœ€é«˜å¾—åˆ†: 0</div>
            <div id="score">å¾—åˆ†: 0</div>
            <canvas id="gameCanvas" width="800" height="400"></canvas>
            <div id="instructions">æŒ‰ç©ºæ ¼é”®è·³è·ƒ | æŒ‰Ré”®é‡æ–°å¼€å§‹ | ç‚¹å‡»å³ä¾§ç©å®¶å§“åå¯ä»¥å®æ—¶è§‚çœ‹å…¶ä»–ç©å®¶æ¸¸æˆç”»é¢</div>
        </div>

        <div id="leaderboardSidebar">
            <h3>ğŸ† å…¨çƒæ’è¡Œæ¦œ</h3>
            <div id="connectionStatus" class="connection-status offline">
                ğŸ“¡ ç¦»çº¿æ¨¡å¼
            </div>
            <div id="leaderboardContent">
                <div class="no-data">æš‚æ— æ’è¡Œæ¦œæ•°æ®</div>
            </div>
            <div id="lastUpdated" class="last-updated">
                ç­‰å¾…è¿æ¥...
            </div>
        </div>
    </div>

    <!-- å•ä¸ªç©å®¶æ¸¸æˆç”»é¢æ˜¾ç¤ºåŒºåŸŸ -->
    <div id="singlePlayerViewContainer" style="display: none;">
        <div class="single-player-view">
            <div class="single-player-header">
                <div>
                    <h3 id="viewingPlayerName">ğŸ® è§‚çœ‹ç©å®¶æ¸¸æˆç”»é¢</h3>
                    <div id="viewingPlayerStats" class="player-stats"></div>
                </div>
                <button class="close-view-btn" onclick="closeSinglePlayerView()">å…³é—­è§‚çœ‹</button>
            </div>
            <canvas id="singlePlayerCanvas" class="large-game-canvas" width="800" height="300"></canvas>
        </div>
    </div>

    <!-- æ¸…é™¤æ•°æ®æŒ‰é’®
    <div id="clearDataContainer">
        <button id="clearAllDataBtn" onclick="clearAllData()">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æ•°æ®</button>
    </div> -->

    <!-- MultiSYNQ CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@multisynq/client@1.0.4/bundled/multisynq-client.min.js"></script>

    <script>
        // MultiSYNQé…ç½®
        const MULTISYNQ_API_KEY = '2zzvzIyyiEaYwTZQ6AjAvZzxvlsDOYzW2XSNgYbgjX';
        const APP_ID = 'com.example.black_jack';

        // ç”Ÿæˆéšæœºç©å®¶åå­—
        const playerNames = [
            'è·³è·ƒå¤§å¸ˆ', 'é£è¡Œä¾ ', 'é—ªç”µå°å­', 'è¶…çº§ç›ä¸½', 'å¿è€…é¾Ÿ',
            'ç«ç®­äºº', 'é£ä¹‹å­', 'é›·ç¥', 'å…‰é€Ÿä¾ ', 'é’¢é“ä¾ ',
            'èœ˜è››ä¾ ', 'ç»¿å·¨äºº', 'ç¾é˜Ÿ', 'é»‘å¯¡å¦‡', 'é¹°çœ¼',
            'å¥‡å¼‚åšå£«', 'æ˜Ÿçˆµ', 'ç«ç®­æµ£ç†Š', 'æ ¼é²ç‰¹', 'å¡é­”æ‹‰'
        ];
        const currentPlayerName = playerNames[Math.floor(Math.random() * playerNames.length)] + Math.floor(Math.random() * 1000);

        // MultiSYNQç›¸å…³å˜é‡
        let multisynqSession = null;
        let gameModel = null;
        let isConnected = false;

        // æ¸¸æˆç”»å¸ƒå’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const playerInfoElement = document.getElementById('playerInfo');
        const leaderboardContentElement = document.getElementById('leaderboardContent');
        const connectionStatusElement = document.getElementById('connectionStatus');
        const lastUpdatedElement = document.getElementById('lastUpdated');

        // æ›´æ–°ç©å®¶ä¿¡æ¯æ˜¾ç¤º
        function updatePlayerInfoDisplay() {
            const status = isConnected ? 'åœ¨çº¿' : 'ç¦»çº¿';
            playerInfoElement.textContent = `ç©å®¶: ${currentPlayerName} | çŠ¶æ€: ${status}`;

            if (isConnected) {
                playerInfoElement.classList.remove('offline');
            } else {
                playerInfoElement.classList.add('offline');
            }

            // æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
            updateConnectionStatusDisplay();
        }

        // æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
        function updateConnectionStatusDisplay() {
            if (isConnected) {
                connectionStatusElement.textContent = 'ğŸŒ åœ¨çº¿æ¨¡å¼';
                connectionStatusElement.className = 'connection-status online';
            } else {
                connectionStatusElement.textContent = 'ğŸ“¡ ç¦»çº¿æ¨¡å¼';
                connectionStatusElement.className = 'connection-status offline';
            }
        }

        // æ¸…ç†æœ¬åœ°å­˜å‚¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        function clearLocalStorage() {
            // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„æœ¬åœ°æ’è¡Œæ¦œæ•°æ®
            localStorage.removeItem('jumpGameLeaderboard');
            localStorage.removeItem('localLeaderboard');
            console.log("Cleared any existing local leaderboard data");
        }

        // æ›´æ–°æ’è¡Œæ¦œæ˜¾ç¤º
        function updateLeaderboardDisplay(leaderboard = []) {
            if (!leaderboard || leaderboard.length === 0) {
                leaderboardContentElement.innerHTML = '<div class="no-data">æš‚æ— æ’è¡Œæ¦œæ•°æ®</div>';
                if (!lastUpdatedElement.textContent.includes('æœ¬åœ°æ•°æ®')) {
                    lastUpdatedElement.textContent = 'ç­‰å¾…æ•°æ®...';
                }
                return;
            }

            let html = '';
            leaderboard.forEach((entry, index) => {
                const rank = index + 1;
                const medal = rank === 1 ? 'ğŸ¥‡' : rank === 2 ? 'ğŸ¥ˆ' : rank === 3 ? 'ğŸ¥‰' : '';
                const rankClass = rank <= 3 ? `rank-${rank}` : '';
                const isCurrentPlayer = entry.playerName === currentPlayerName;
                const clickableClass = !isCurrentPlayer ? 'clickable-player' : '';

                html += `
                    <div class="leaderboard-entry ${rankClass} ${clickableClass}"
                         ${!isCurrentPlayer ? `onclick="togglePlayerGameView('${entry.playerName}')"` : ''}>
                        <div class="rank-number">
                            <span class="medal">${medal}</span>${rank}
                        </div>
                        <div class="player-name" title="${entry.playerName}">
                            ${entry.playerName}
                            ${!isCurrentPlayer ? '<span class="view-game-hint">ğŸ‘ï¸</span>' : ''}
                        </div>
                        <div class="player-score">
                            ${entry.score.toLocaleString()}
                        </div>
                    </div>
                `;
            });

            leaderboardContentElement.innerHTML = html;

            console.log("Leaderboard display updated with", leaderboard.length, "entries");
        }

        // æ¸¸æˆçŠ¶æ€
        let gameRunning = true;
        let score = 0;
        let highScore = 0;
        let gameSpeed = 3; // åŠ å¿«1.5å€ (2.2 * 1.5)
        let frameCount = 0;

        // å®æ—¶æ¸¸æˆçŠ¶æ€ä¸Šä¼ æ§åˆ¶
        let lastGameStateUpload = 0;
        const GAME_STATE_UPLOAD_INTERVAL = 50; // æ¯500æ¯«ç§’ä¸Šä¼ ä¸€æ¬¡æ¸¸æˆçŠ¶æ€ (2fps) - é™ä½é¢‘ç‡ä¾¿äºè°ƒè¯•
        let gameStateUploadEnabled = true;
        let lastGameState = null; // å­˜å‚¨ä¸Šæ¬¡çš„æ¸¸æˆçŠ¶æ€ï¼Œç”¨äºæ¯”è¾ƒå˜åŒ–
        let gameStateUploadErrors = 0; // ä¸Šä¼ é”™è¯¯è®¡æ•°
        const MAX_UPLOAD_ERRORS = 5; // æœ€å¤§é”™è¯¯æ¬¡æ•°
        let forceUploadForTesting = true; // å¼ºåˆ¶ä¸Šä¼ ç”¨äºæµ‹è¯•

        // å•ä¸ªç©å®¶è§‚çœ‹åŠŸèƒ½
        let currentViewingPlayer = null; // å½“å‰æ­£åœ¨è§‚çœ‹çš„ç©å®¶
        let allPlayersStates = new Map(); // å­˜å‚¨æ‰€æœ‰ç©å®¶çš„æ¸¸æˆçŠ¶æ€

        // View Smoothing ç³»ç»Ÿ
        let smoothedStates = new Map(); // å­˜å‚¨å¹³æ»‘åçš„æ¸¸æˆçŠ¶æ€
        let previousStates = new Map(); // å­˜å‚¨ä¸Šä¸€å¸§çš„æ¸¸æˆçŠ¶æ€
        let smoothingAnimationId = null; // å¹³æ»‘åŠ¨ç”»ID
        let smoothingFactor = 0.15; // å¹³æ»‘å› å­ (0-1, è¶Šå°è¶Šå¹³æ»‘)
        let smoothingEnabled = true; // å¹³æ»‘å¼€å…³

        // MultiSYNQ Modelç±» - å¤„ç†å…±äº«æ¸¸æˆçŠ¶æ€
        class GameModel extends Multisynq.Model {
            init() {
                super.init();
                // åˆå§‹åŒ–å…±äº«æ’è¡Œæ¦œæ•°æ® - è¿™å°†åœ¨æ‰€æœ‰å®¢æˆ·ç«¯ä¹‹é—´å…±äº«
                if (!this.leaderboard) {
                    this.leaderboard = [];
                }

                // åˆå§‹åŒ–å®æ—¶æ¸¸æˆçŠ¶æ€æ•°æ®å­˜å‚¨
                if (!this.gameStates) {
                    this.gameStates = new Map(); // å­˜å‚¨æ¯ä¸ªç©å®¶çš„æ¸¸æˆçŠ¶æ€
                }

                // è®¢é˜…äº‹ä»¶
                this.subscribe(this.sessionId, "score-submit", this.handleScoreSubmit);
                this.subscribe(this.sessionId, "request-leaderboard", this.sendLeaderboard);
                this.subscribe(this.sessionId, "game-state-update", this.handleGameStateUpdate);
                this.subscribe(this.sessionId, "request-game-states", this.sendGameStates);
                this.subscribe(this.sessionId, "clear-all-data", this.handleClearAllData);

                console.log("GameModel initialized. Current leaderboard:", this.leaderboard);

                // ç«‹å³å¹¿æ’­å½“å‰æ’è¡Œæ¦œçŠ¶æ€
                setTimeout(() => {
                    if (this.sendLeaderboard) {
                        this.sendLeaderboard();
                    }
                }, 1000);

                // å®šæœŸå¹¿æ’­æ’è¡Œæ¦œæ›´æ–°
                setTimeout(() => {
                    if (this.periodicBroadcast) {
                        this.periodicBroadcast();
                    }
                }, 5000);
            }

            handleScoreSubmit(data) {
                console.log("Model received score submission:", data);
                const { playerName, score } = data;

                // ç¡®ä¿leaderboardå­˜åœ¨
                if (!this.leaderboard) {
                    this.leaderboard = [];
                }

                // æ›´æ–°æ’è¡Œæ¦œ
                const existingIndex = this.leaderboard.findIndex(entry => entry.playerName === playerName);
                let updated = false;

                if (existingIndex >= 0) {
                    // åªæœ‰å½“æ–°åˆ†æ•°æ›´é«˜æ—¶æ‰æ›´æ–°
                    if (score > this.leaderboard[existingIndex].score) {
                        this.leaderboard[existingIndex] = {
                            playerName,
                            score,
                            timestamp: Date.now(),
                            sessionId: this.sessionId
                        };
                        console.log(`Updated existing player ${playerName}: ${this.leaderboard[existingIndex].score} â†’ ${score}`);
                        updated = true;
                    } else {
                        console.log(`Score ${score} not higher than existing ${this.leaderboard[existingIndex].score} for ${playerName}`);
                    }
                } else {
                    this.leaderboard.push({
                        playerName,
                        score,
                        timestamp: Date.now(),
                        sessionId: this.sessionId
                    });
                    console.log(`Added new player ${playerName}: ${score}`);
                    updated = true;
                }

                if (updated) {
                    // æŒ‰åˆ†æ•°æ’åºï¼Œä¸é™åˆ¶æ•°é‡
                    this.leaderboard.sort((a, b) => b.score - a.score);

                    console.log("Updated leaderboard:", this.leaderboard);

                    // ç«‹å³å¹¿æ’­æ›´æ–°
                    this.sendLeaderboard();
                }
            }

            sendLeaderboard() {
                console.log("Broadcasting leaderboard to all clients:", this.leaderboard);
                this.publish(this.sessionId, "leaderboard-update", {
                    leaderboard: this.leaderboard || [],
                    timestamp: Date.now(),
                    source: "model"
                });
            }

            periodicBroadcast() {
                // å®šæœŸå¹¿æ’­å½“å‰çŠ¶æ€
                this.sendLeaderboard();
                this.cleanupGameStates(); // æ¸…ç†è¿‡æœŸçš„æ¸¸æˆçŠ¶æ€
                // æ¯30ç§’å¹¿æ’­ä¸€æ¬¡
                setTimeout(() => {
                    if (this.periodicBroadcast) {
                        this.periodicBroadcast();
                    }
                }, 30000);
            }

            handleScoreUpdate(data) {
                const { playerName, score, timestamp } = data;

                // æ›´æ–°æ’è¡Œæ¦œ
                const existingIndex = this.leaderboard.findIndex(entry => entry.playerName === playerName);
                if (existingIndex >= 0) {
                    // åªæœ‰å½“æ–°åˆ†æ•°æ›´é«˜æ—¶æ‰æ›´æ–°
                    if (score > this.leaderboard[existingIndex].score) {
                        this.leaderboard[existingIndex] = { playerName, score, timestamp };
                    }
                } else {
                    this.leaderboard.push({ playerName, score, timestamp });
                }

                // æŒ‰åˆ†æ•°æ’åºï¼Œä¸é™åˆ¶æ•°é‡
                this.leaderboard.sort((a, b) => b.score - a.score);

                // é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯æ›´æ–°æ’è¡Œæ¦œ
                this.publish(this.sessionId, "leaderboard-updated", {
                    leaderboard: this.leaderboard,
                    timestamp: this.now()
                });

                console.log("Score updated for", playerName, ":", score);
            }

            handlePlayerJoin(data) {
                const { playerName, timestamp } = data;
                this.currentPlayers.set(playerName, { joinTime: timestamp, lastSeen: timestamp });

                this.publish(this.sessionId, "player-list-updated", {
                    players: Array.from(this.currentPlayers.keys()),
                    timestamp: this.now()
                });

                console.log("Player joined:", playerName);
            }

            handlePlayerLeave(data) {
                const { playerName } = data;
                this.currentPlayers.delete(playerName);

                this.publish(this.sessionId, "player-list-updated", {
                    players: Array.from(this.currentPlayers.keys()),
                    timestamp: this.now()
                });

                console.log("Player left:", playerName);
            }

            // å¤„ç†æ¸¸æˆçŠ¶æ€æ›´æ–°
            handleGameStateUpdate(data) {
                console.log("Model received game state update:", data);
                const { playerName, gameState } = data;

                // ç¡®ä¿gameStateså­˜åœ¨
                if (!this.gameStates) {
                    this.gameStates = new Map();
                }

                // æ›´æ–°ç©å®¶çš„æ¸¸æˆçŠ¶æ€
                this.gameStates.set(playerName, {
                    ...gameState,
                    timestamp: Date.now(),
                    sessionId: this.sessionId
                });

                console.log(`Updated game state for ${playerName}:`, gameState);

                // å¹¿æ’­æ¸¸æˆçŠ¶æ€æ›´æ–°ç»™æ‰€æœ‰å®¢æˆ·ç«¯
                this.sendGameStates();
            }

            // å‘é€æ‰€æœ‰æ¸¸æˆçŠ¶æ€ç»™å®¢æˆ·ç«¯
            sendGameStates() {
                if (!this.gameStates) {
                    this.gameStates = new Map();
                }

                // å°†Mapè½¬æ¢ä¸ºå¯¹è±¡ä»¥ä¾¿ä¼ è¾“
                const gameStatesObject = {};
                this.gameStates.forEach((state, playerName) => {
                    gameStatesObject[playerName] = state;
                });

                console.log("Broadcasting game states to all clients:", gameStatesObject);
                this.publish(this.sessionId, "game-states-update", {
                    gameStates: gameStatesObject,
                    timestamp: Date.now(),
                    source: "model"
                });
            }

            // æ¸…ç†è¿‡æœŸçš„æ¸¸æˆçŠ¶æ€ï¼ˆè¶…è¿‡30ç§’æ²¡æœ‰æ›´æ–°çš„ç©å®¶ï¼‰
            cleanupGameStates() {
                if (!this.gameStates) return;

                const now = Date.now();
                const TIMEOUT = 30000; // 30ç§’è¶…æ—¶

                this.gameStates.forEach((state, playerName) => {
                    if (now - state.timestamp > TIMEOUT) {
                        console.log(`Removing expired game state for ${playerName}`);
                        this.gameStates.delete(playerName);
                    }
                });

                // å¦‚æœæœ‰çŠ¶æ€è¢«æ¸…ç†ï¼Œå¹¿æ’­æ›´æ–°
                this.sendGameStates();
            }

            // å¤„ç†æ¸…é™¤æ‰€æœ‰æ•°æ®è¯·æ±‚
            handleClearAllData(data) {
                console.log("ğŸ—‘ï¸ Model received clear all data request:", data);
                const { requestedBy, timestamp } = data;

                try {
                    // æ¸…é™¤æ’è¡Œæ¦œæ•°æ®
                    this.leaderboard = [];
                    console.log("âœ… Leaderboard cleared");

                    // æ¸…é™¤æ‰€æœ‰æ¸¸æˆçŠ¶æ€æ•°æ®
                    if (this.gameStates) {
                        this.gameStates.clear();
                    }
                    console.log("âœ… Game states cleared");

                    // æ¸…é™¤ç©å®¶åˆ—è¡¨
                    if (this.currentPlayers) {
                        this.currentPlayers.clear();
                    }
                    console.log("âœ… Player list cleared");

                    // å¹¿æ’­æ¸…é™¤å®Œæˆäº‹ä»¶
                    this.publish(this.sessionId, "data-cleared", {
                        clearedBy: requestedBy,
                        timestamp: Date.now(),
                        message: "æ‰€æœ‰MultiSYNQæ•°æ®å·²æ¸…é™¤"
                    });

                    // å¹¿æ’­ç©ºçš„æ’è¡Œæ¦œå’Œæ¸¸æˆçŠ¶æ€
                    this.sendLeaderboard();
                    this.sendGameStates();

                    console.log(`ğŸ‰ All MultiSYNQ data cleared by ${requestedBy}`);

                } catch (error) {
                    console.error("âŒ Error clearing MultiSYNQ data:", error);

                    // å¹¿æ’­é”™è¯¯äº‹ä»¶
                    this.publish(this.sessionId, "clear-data-error", {
                        error: error.message,
                        requestedBy: requestedBy,
                        timestamp: Date.now()
                    });
                }
            }
        }

        // æ³¨å†ŒModelç±»
        GameModel.register("GameModel");

        // MultiSYNQ Viewç±» - å¤„ç†æœ¬åœ°UIæ›´æ–°
        class GameView extends Multisynq.View {
            constructor(model) {
                super(model);
                this.model = model;
                this.subscribe(this.model.sessionId, "leaderboard-update", this.onLeaderboardUpdate);
                this.subscribe(this.model.sessionId, "game-states-update", this.onGameStatesUpdate);
                this.subscribe(this.model.sessionId, "data-cleared", this.onDataCleared);
                this.subscribe(this.model.sessionId, "clear-data-error", this.onClearDataError);

                // å­˜å‚¨å…¶ä»–ç©å®¶çš„æ¸¸æˆçŠ¶æ€
                this.otherPlayersStates = new Map();

                console.log("GameView initialized");

                // è¿æ¥åç«‹å³è¯·æ±‚å½“å‰æ’è¡Œæ¦œå’Œæ¸¸æˆçŠ¶æ€
                setTimeout(() => {
                    if (this.requestCurrentLeaderboard) {
                        this.requestCurrentLeaderboard();
                    }
                    if (this.requestCurrentGameStates) {
                        this.requestCurrentGameStates();
                    }
                }, 500);
            }

            onLeaderboardUpdate(data) {
                console.log("View received leaderboard update:", data);
                if (data && data.leaderboard) {
                    // æ›´æ–°å…¨å±€æ’è¡Œæ¦œæ˜¾ç¤º
                    if (typeof updateLeaderboardDisplay === 'function') {
                        updateLeaderboardDisplay(data.leaderboard);

                        // æ›´æ–°æœ€åæ›´æ–°æ—¶é—´
                        if (typeof lastUpdatedElement !== 'undefined' && lastUpdatedElement) {
                            const now = new Date();
                            lastUpdatedElement.textContent = `æœ€åæ›´æ–°: ${now.toLocaleTimeString()} (MultiSYNQ)`;
                        }
                    }

                    // æ›´æ–°æœ¬åœ°æœ€é«˜åˆ†æ˜¾ç¤º
                    if (data.leaderboard.length > 0 && typeof highScore !== 'undefined') {
                        const globalHighScore = data.leaderboard[0].score;
                        if (globalHighScore > highScore) {
                            highScore = globalHighScore;
                            if (typeof updateHighScoreDisplay === 'function') {
                                updateHighScoreDisplay();
                            }
                        }
                    }
                }
            }

            requestCurrentLeaderboard() {
                console.log("Requesting current leaderboard from model");
                try {
                    this.publish(this.model.sessionId, "request-leaderboard", {
                        timestamp: Date.now()
                    });
                } catch (error) {
                    console.error("Failed to request leaderboard:", error);
                }
            }

            // å¤„ç†æ¸¸æˆçŠ¶æ€æ›´æ–°
            onGameStatesUpdate(data) {
                console.log("View received game states update:", data);
                if (data && data.gameStates) {
                    // æ›´æ–°æ‰€æœ‰ç©å®¶çš„æ¸¸æˆçŠ¶æ€
                    allPlayersStates.clear();
                    this.otherPlayersStates.clear();

                    Object.entries(data.gameStates).forEach(([playerName, gameState]) => {
                        allPlayersStates.set(playerName, gameState);
                        // ä¸å­˜å‚¨è‡ªå·±çš„æ¸¸æˆçŠ¶æ€åˆ°otherPlayersStates
                        if (playerName !== currentPlayerName) {
                            this.otherPlayersStates.set(playerName, gameState);
                        }
                    });

                    console.log(`Updated game states for ${this.otherPlayersStates.size} other players`);

                    // å¦‚æœæ­£åœ¨è§‚çœ‹æŸä¸ªç©å®¶ï¼Œæ›´æ–°å…¶ç”»é¢
                    if (currentViewingPlayer && allPlayersStates.has(currentViewingPlayer)) {
                        updateSinglePlayerView(currentViewingPlayer, allPlayersStates.get(currentViewingPlayer));
                    }
                }
            }

            // è¯·æ±‚å½“å‰æ¸¸æˆçŠ¶æ€
            requestCurrentGameStates() {
                console.log("Requesting current game states from model");
                try {
                    this.publish(this.model.sessionId, "request-game-states", {
                        timestamp: Date.now()
                    });
                } catch (error) {
                    console.error("Failed to request game states:", error);
                }
            }

            // åˆ†æ•°æäº¤æ–¹æ³•
            submitScore(playerName, score) {
                console.log(`Submitting score to MultiSYNQ: ${playerName} - ${score}`);
                try {
                    this.publish(this.model.sessionId, "score-submit", {
                        playerName: playerName,
                        score: score,
                        timestamp: Date.now()
                    });
                    console.log("Score submitted successfully to MultiSYNQ");
                } catch (error) {
                    console.error("Failed to submit score to MultiSYNQ:", error);
                    throw error;
                }
            }

            // æ¸¸æˆçŠ¶æ€æäº¤æ–¹æ³•
            submitGameState(playerName, gameState) {
                console.log(`Submitting game state to MultiSYNQ: ${playerName}`, gameState);
                try {
                    this.publish(this.model.sessionId, "game-state-update", {
                        playerName: playerName,
                        gameState: gameState,
                        timestamp: Date.now()
                    });
                } catch (error) {
                    console.error("Failed to submit game state to MultiSYNQ:", error);
                    throw error;
                }
            }

            // è·å–å…¶ä»–ç©å®¶çš„æ¸¸æˆçŠ¶æ€
            getOtherPlayersStates() {
                return this.otherPlayersStates;
            }

            // å¤„ç†æ•°æ®æ¸…é™¤å®Œæˆäº‹ä»¶
            onDataCleared(data) {
                console.log("ğŸ“¢ Data cleared notification:", data);
                const { clearedBy, message } = data;

                // æ˜¾ç¤ºé€šçŸ¥æ¶ˆæ¯
                alert(`ğŸ‰ ${message}\n\næ“ä½œè€…ï¼š${clearedBy}\n\né¡µé¢å°†è‡ªåŠ¨åˆ·æ–°ä»¥æ˜¾ç¤ºæœ€æ–°çŠ¶æ€ã€‚`);

                // è‡ªåŠ¨åˆ·æ–°é¡µé¢
                setTimeout(() => {
                    location.reload();
                }, 2000);
            }

            // å¤„ç†æ¸…é™¤æ•°æ®é”™è¯¯äº‹ä»¶
            onClearDataError(data) {
                console.error("âŒ Clear data error:", data);
                const { error, requestedBy } = data;

                alert(`âŒ æ¸…é™¤æ•°æ®å¤±è´¥ï¼\n\né”™è¯¯ä¿¡æ¯ï¼š${error}\næ“ä½œè€…ï¼š${requestedBy}`);
            }
        }

        // Viewç±»ä¸éœ€è¦æ³¨å†Œï¼Œåªæœ‰Modelç±»éœ€è¦æ³¨å†Œ

        // é‡åŠ›å’Œè·³è·ƒç‰©ç†å‚æ•°
        const BASE_GRAVITY = 0.6;
        const JUMP_FORCE = -12;
        const GROUND_Y = canvas.height - 60;
        const BASE_GAME_SPEED = 3; // åŸºç¡€æ¸¸æˆé€Ÿåº¦

        // ç©å®¶è§’è‰²å¯¹è±¡
        const player = {
            x: 100,
            y: GROUND_Y,
            width: 32,
            height: 32,
            velocityY: 0,
            isJumping: false,
            color: '#FF6B6B',
            image: null,
            imageLoaded: false
        };

        // é‡‘å¸å›¾ç‰‡å¯¹è±¡
        const coinImage = {
            image: null,
            imageLoaded: false
        };

        // åˆå§‹åŒ–MultiSYNQè¿æ¥
        async function initMultiSYNQ() {
            try {
                console.log("Connecting to MultiSYNQ...");
                multisynqSession = await Multisynq.Session.join({
                    appId: APP_ID,
                    apiKey: MULTISYNQ_API_KEY,
                    name: "jump-game-global-leaderboard", // å›ºå®šä¼šè¯åï¼Œæ‰€æœ‰ç©å®¶å…±äº«
                    password: "jump-game-session", // å…±äº«å¯†ç ï¼Œæ‰€æœ‰ç©å®¶ä½¿ç”¨ç›¸åŒå¯†ç è¿›å…¥åŒä¸€ä¼šè¯
                    model: GameModel,
                    view: GameView,
                    tps: 20 // æ¯ç§’20æ¬¡åŒæ­¥
                });

                gameModel = multisynqSession.view.model;
                isConnected = true;

                console.log("ğŸ‰ Connected to MultiSYNQ successfully!");
                console.log("ğŸ® Player name:", currentPlayerName);
                console.log("ğŸ”— Session ID:", multisynqSession.id);
                console.log("ğŸ“¡ Session details:", {
                    id: multisynqSession.id,
                    name: "jump-game-global-leaderboard",
                    appId: APP_ID,
                    connected: isConnected
                });

                // æ›´æ–°UIæ˜¾ç¤º
                updatePlayerInfoDisplay();

                // è¿æ¥æˆåŠŸåï¼Œæ¸…ç©ºæœ¬åœ°æ˜¾ç¤ºï¼Œç­‰å¾…MultiSYNQæ•°æ®
                console.log("Connected to MultiSYNQ, waiting for leaderboard data...");
                updateLeaderboardDisplay([]);
                if (lastUpdatedElement) {
                    lastUpdatedElement.textContent = 'å·²è¿æ¥ï¼Œæ­£åœ¨åŠ è½½æ’è¡Œæ¦œ...';
                }

                // è¯·æ±‚å½“å‰æ’è¡Œæ¦œçŠ¶æ€
                setTimeout(() => {
                    if (multisynqSession && multisynqSession.view) {
                        console.log("Requesting current leaderboard from MultiSYNQ...");
                        multisynqSession.view.requestCurrentLeaderboard();

                        // å¦‚æœæ¨¡å‹ä¸­å·²æœ‰æ•°æ®ï¼Œç«‹å³æ˜¾ç¤º
                        if (multisynqSession.view.model && multisynqSession.view.model.leaderboard) {
                            const currentBoard = multisynqSession.view.model.leaderboard;
                            console.log("Found existing leaderboard in model:", currentBoard);
                            updateLeaderboardDisplay(currentBoard);
                            if (lastUpdatedElement) {
                                lastUpdatedElement.textContent = `å·²åŠ è½½ ${currentBoard.length} åç©å®¶`;
                            }
                        }
                    }
                }, 1000);

                // æš‚æ—¶ä¸å‘é€ç©å®¶åŠ å…¥é€šçŸ¥ï¼Œé¿å…realmé”™è¯¯
                console.log("MultiSYNQ session ready for score updates");

                // é¡µé¢å…³é—­æ—¶çš„æ¸…ç†ï¼ˆæš‚æ—¶ç®€åŒ–ï¼‰
                window.addEventListener('beforeunload', () => {
                    console.log("Page unloading, cleaning up MultiSYNQ session");
                });

            } catch (error) {
                console.error("Failed to connect to MultiSYNQ:", error);
                isConnected = false;
                // æ›´æ–°UIæ˜¾ç¤º
                updatePlayerInfoDisplay();
                // æ˜¾ç¤ºç¦»çº¿çŠ¶æ€ - ä¸æ˜¾ç¤ºä»»ä½•æ’è¡Œæ¦œæ•°æ®
                showEmptyLeaderboard();
                if (lastUpdatedElement) {
                    lastUpdatedElement.textContent = 'è¿æ¥å¤±è´¥ - æ— æ³•è®¿é—®æ’è¡Œæ¦œ';
                }
                // å³ä½¿è¿æ¥å¤±è´¥ï¼Œæ¸¸æˆä»ç„¶å¯ä»¥å•æœºè¿è¡Œ
            }
        }

        // ä¸Šä¼ åˆ†æ•°åˆ°MultiSYNQï¼ˆä»…ä½¿ç”¨MultiSYNQå­˜å‚¨ï¼‰
        function uploadScoreToMultiSYNQ(playerName, score) {
            console.log(`Uploading score to MultiSYNQ: ${playerName} - ${score}`);

            if (isConnected && multisynqSession && multisynqSession.view) {
                try {
                    multisynqSession.view.submitScore(playerName, score);
                    console.log(`Score successfully submitted to MultiSYNQ: ${playerName} - ${score}`);
                } catch (error) {
                    console.error("Failed to submit score to MultiSYNQ:", error);
                    // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ç»™ç”¨æˆ·
                    if (typeof lastUpdatedElement !== 'undefined' && lastUpdatedElement) {
                        lastUpdatedElement.textContent = 'åˆ†æ•°ä¸Šä¼ å¤±è´¥ - è¯·æ£€æŸ¥è¿æ¥';
                    }
                }
            } else {
                console.log("MultiSYNQ not connected - score not saved");
                // æ˜¾ç¤ºæœªè¿æ¥çŠ¶æ€
                if (typeof lastUpdatedElement !== 'undefined' && lastUpdatedElement) {
                    lastUpdatedElement.textContent = 'æœªè¿æ¥åˆ°MultiSYNQ - åˆ†æ•°æœªä¿å­˜';
                }

                // å¯é€‰ï¼šæ˜¾ç¤ºæç¤ºä¿¡æ¯
                if (typeof updateLeaderboardDisplay === 'function') {
                    updateLeaderboardDisplay([]);
                    if (typeof leaderboardContentElement !== 'undefined' && leaderboardContentElement) {
                        leaderboardContentElement.innerHTML = '<div class="no-data">è¯·è¿æ¥åˆ°MultiSYNQä»¥ä¿å­˜å’ŒæŸ¥çœ‹æ’è¡Œæ¦œ</div>';
                    }
                }
            }
        }

        // æ”¶é›†å½“å‰æ¸¸æˆçŠ¶æ€
        function collectGameState() {
            return {
                // ç©å®¶çŠ¶æ€
                player: {
                    x: player.x,
                    y: player.y,
                    width: player.width,
                    height: player.height,
                    velocityY: player.velocityY,
                    isJumping: player.isJumping,
                    color: player.color
                },
                // éšœç¢ç‰©çŠ¶æ€ï¼ˆåªå‘é€å¯è§çš„éšœç¢ç‰©ï¼‰
                obstacles: obstacles.filter(obstacle => obstacle.x > -obstacle.width && obstacle.x < canvas.width + 100).map(obstacle => ({
                    x: obstacle.x,
                    y: obstacle.y,
                    width: obstacle.width,
                    height: obstacle.height,
                    type: obstacle.type
                })),
                // é“å…·çŠ¶æ€
                powerups: powerups.filter(powerup => powerup.x > -powerup.width && powerup.x < canvas.width + 100).map(powerup => ({
                    x: powerup.x,
                    y: powerup.y,
                    width: powerup.width,
                    height: powerup.height,
                    type: powerup.type
                })),
                // æ¸¸æˆçŠ¶æ€
                score: score,
                gameSpeed: gameSpeed,
                frameCount: frameCount,
                gameRunning: gameRunning,
                // æ— æ•ŒçŠ¶æ€
                invincible: invincible,
                invincibleTime: invincibleTime,
                // åœ°é¢æ»šåŠ¨åç§»
                groundOffset: groundOffset % 40 // åªå‘é€ç›¸å¯¹åç§»
            };
        }

        // æ£€æŸ¥æ¸¸æˆçŠ¶æ€æ˜¯å¦æœ‰æ˜¾è‘—å˜åŒ–
        function hasSignificantGameStateChange(newState, oldState) {
            if (!oldState) return true; // ç¬¬ä¸€æ¬¡ä¸Šä¼ 

            // æ£€æŸ¥ç©å®¶ä½ç½®å˜åŒ–ï¼ˆè¶…è¿‡1åƒç´ ï¼‰
            if (Math.abs(newState.player.x - oldState.player.x) > 1 ||
                Math.abs(newState.player.y - oldState.player.y) > 1) {
                return true;
            }

            // æ£€æŸ¥ç©å®¶è·³è·ƒçŠ¶æ€å˜åŒ–
            if (newState.player.isJumping !== oldState.player.isJumping) {
                return true;
            }

            // æ£€æŸ¥åˆ†æ•°å˜åŒ–
            if (newState.score !== oldState.score) {
                return true;
            }

            // æ£€æŸ¥æ¸¸æˆé€Ÿåº¦å˜åŒ–
            if (Math.abs(newState.gameSpeed - oldState.gameSpeed) > 0.01) {
                return true;
            }

            // æ£€æŸ¥éšœç¢ç‰©æ•°é‡å˜åŒ–
            if (newState.obstacles.length !== oldState.obstacles.length) {
                return true;
            }

            // æ£€æŸ¥é“å…·æ•°é‡å˜åŒ–
            if (newState.powerups.length !== oldState.powerups.length) {
                return true;
            }

            // æ£€æŸ¥æ— æ•ŒçŠ¶æ€å˜åŒ–
            if (newState.invincible !== oldState.invincible) {
                return true;
            }

            // æ£€æŸ¥æ¸¸æˆè¿è¡ŒçŠ¶æ€å˜åŒ–
            if (newState.gameRunning !== oldState.gameRunning) {
                return true;
            }

            // å®šæœŸå¼ºåˆ¶ä¸Šä¼ ï¼ˆæ¯3ç§’ï¼‰
            const now = Date.now();
            if (now - lastGameStateUpload > 3000) {
                return true;
            }

            return false; // æ²¡æœ‰æ˜¾è‘—å˜åŒ–
        }

        // å‹ç¼©æ¸¸æˆçŠ¶æ€æ•°æ®
        function compressGameState(gameState) {
            return {
                // ç©å®¶çŠ¶æ€ï¼ˆä¿ç•™å…³é”®ä¿¡æ¯ï¼‰
                p: {
                    x: Math.round(gameState.player.x),
                    y: Math.round(gameState.player.y),
                    vY: Math.round(gameState.player.velocityY * 10) / 10, // ä¿ç•™ä¸€ä½å°æ•°
                    j: gameState.player.isJumping
                },
                // éšœç¢ç‰©ï¼ˆåªä¿ç•™ä½ç½®å’Œç±»å‹ï¼‰
                o: gameState.obstacles.map(obs => ({
                    x: Math.round(obs.x),
                    y: Math.round(obs.y),
                    w: obs.width,
                    h: obs.height,
                    t: obs.type
                })),
                // é“å…·
                pu: gameState.powerups.map(pu => ({
                    x: Math.round(pu.x),
                    y: Math.round(pu.y),
                    t: pu.type
                })),
                // æ¸¸æˆçŠ¶æ€
                s: gameState.score,
                gs: Math.round(gameState.gameSpeed * 100) / 100, // ä¿ç•™ä¸¤ä½å°æ•°
                r: gameState.gameRunning,
                i: gameState.invincible,
                go: Math.round(gameState.groundOffset)
            };
        }

        // ä¸Šä¼ æ¸¸æˆçŠ¶æ€åˆ°MultiSYNQ
        function uploadGameStateToMultiSYNQ() {
            if (!gameStateUploadEnabled || !gameRunning) {
                return;
            }

            // æ£€æŸ¥é”™è¯¯æ¬¡æ•°
            if (gameStateUploadErrors >= MAX_UPLOAD_ERRORS) {
                console.warn("Too many upload errors, disabling game state upload");
                gameStateUploadEnabled = false;
                return;
            }

            const now = Date.now();
            if (now - lastGameStateUpload < GAME_STATE_UPLOAD_INTERVAL) {
                return; // è¿˜æ²¡åˆ°ä¸Šä¼ æ—¶é—´
            }

            if (isConnected && multisynqSession && multisynqSession.view) {
                try {
                    const gameState = collectGameState();

                    // æµ‹è¯•æœŸé—´å¼ºåˆ¶ä¸Šä¼ æ‰€æœ‰æ•°æ®
                    if (!forceUploadForTesting && !hasSignificantGameStateChange(gameState, lastGameState)) {
                        return; // æ²¡æœ‰æ˜¾è‘—å˜åŒ–ï¼Œè·³è¿‡ä¸Šä¼ 
                    }

                    // å‹ç¼©æ•°æ®
                    const compressedState = compressGameState(gameState);

                    // æ·»åŠ è°ƒè¯•ä¿¡æ¯
                    if (frameCount % 60 === 0) { // æ¯ç§’æ˜¾ç¤ºä¸€æ¬¡
                        console.log("ğŸ”„ Attempting to upload game state...");
                        console.log("ğŸ“¦ Raw game state:", gameState);
                        console.log("ğŸ—œï¸ Compressed state:", compressedState);
                    }

                    multisynqSession.view.submitGameState(currentPlayerName, compressedState);
                    lastGameStateUpload = now;
                    lastGameState = gameState; // ä¿å­˜å½“å‰çŠ¶æ€
                    gameStateUploadErrors = 0; // é‡ç½®é”™è¯¯è®¡æ•°

                    // å¢åŠ è°ƒè¯•ä¿¡æ¯é¢‘ç‡
                    if (frameCount % 300 === 0) { // æ¯5ç§’æ˜¾ç¤ºä¸€æ¬¡
                        console.log(`âœ… Game state uploaded for ${currentPlayerName}:`, compressedState);
                        console.log(`ğŸ“Š Upload stats: errors=${gameStateUploadErrors}, enabled=${gameStateUploadEnabled}`);
                        console.log(`ğŸ”— Session ID: ${multisynqSession.id}`);
                    }
                } catch (error) {
                    console.error("âŒ Failed to upload game state to MultiSYNQ:", error);
                    gameStateUploadErrors++;

                    // å¦‚æœé”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œæš‚æ—¶ç¦ç”¨ä¸Šä¼ 
                    if (gameStateUploadErrors >= MAX_UPLOAD_ERRORS) {
                        gameStateUploadEnabled = false;
                        console.warn(`ğŸš« Disabling game state upload due to ${gameStateUploadErrors} errors`);
                        setTimeout(() => {
                            gameStateUploadEnabled = true;
                            gameStateUploadErrors = 0;
                            console.log("ğŸ”„ Re-enabling game state upload");
                        }, 10000); // 10ç§’åé‡æ–°å¯ç”¨
                    }
                }
            } else {
                // æ·»åŠ è¿æ¥çŠ¶æ€è°ƒè¯•ä¿¡æ¯
                if (frameCount % 300 === 0) {
                    console.log(`ğŸ”Œ Connection status: connected=${isConnected}, session=${!!multisynqSession}, view=${!!(multisynqSession && multisynqSession.view)}`);
                    if (multisynqSession) {
                        console.log(`ğŸ”— Session ID: ${multisynqSession.id}`);
                    }
                }
            }
        }

        // é‡ç½®æ¸¸æˆçŠ¶æ€ä¸Šä¼ 
        function resetGameStateUpload() {
            lastGameState = null;
            gameStateUploadErrors = 0;
            gameStateUploadEnabled = true;
            console.log("Game state upload reset");
        }

        // åˆ‡æ¢ç©å®¶æ¸¸æˆç”»é¢è§‚çœ‹
        function togglePlayerGameView(playerName) {
            console.log(`Toggling view for player: ${playerName}`);

            // å¦‚æœå·²ç»åœ¨è§‚çœ‹è¿™ä¸ªç©å®¶ï¼Œåˆ™å…³é—­è§‚çœ‹
            if (currentViewingPlayer === playerName) {
                closeSinglePlayerView();
                return;
            }

            // æ›´æ–°æ’è¡Œæ¦œä¸­çš„é€‰ä¸­çŠ¶æ€
            updateLeaderboardSelection(playerName);

            // æ˜¾ç¤ºå•ä¸ªç©å®¶è§‚çœ‹ç•Œé¢
            showSinglePlayerView(playerName);
        }

        // æ˜¾ç¤ºå•ä¸ªç©å®¶è§‚çœ‹ç•Œé¢
        function showSinglePlayerView(playerName) {
            currentViewingPlayer = playerName;
            const container = document.getElementById('singlePlayerViewContainer');
            const playerNameElement = document.getElementById('viewingPlayerName');

            container.style.display = 'block';
            playerNameElement.textContent = `ğŸ® è§‚çœ‹ ${playerName} çš„æ¸¸æˆç”»é¢`;

            // å¦‚æœæœ‰è¯¥ç©å®¶çš„æ¸¸æˆçŠ¶æ€ï¼Œç«‹å³æ›´æ–°æ˜¾ç¤º
            if (allPlayersStates.has(playerName)) {
                updateSinglePlayerView(playerName, allPlayersStates.get(playerName));
            }

            console.log(`Now viewing player: ${playerName}`);
        }

        // å…³é—­å•ä¸ªç©å®¶è§‚çœ‹ç•Œé¢
        function closeSinglePlayerView() {
            currentViewingPlayer = null;
            const container = document.getElementById('singlePlayerViewContainer');
            container.style.display = 'none';

            // åœæ­¢å¹³æ»‘åŠ¨ç”»
            stopSmoothingAnimation();

            // æ¸…é™¤å¹³æ»‘çŠ¶æ€æ•°æ®
            smoothedStates.clear();
            previousStates.clear();

            // æ¸…é™¤æ’è¡Œæ¦œé€‰ä¸­çŠ¶æ€
            updateLeaderboardSelection(null);

            console.log('Closed single player view and stopped smoothing');
        }

        // æ›´æ–°æ’è¡Œæ¦œé€‰ä¸­çŠ¶æ€
        function updateLeaderboardSelection(selectedPlayer) {
            const leaderboardEntries = document.querySelectorAll('.leaderboard-entry');
            leaderboardEntries.forEach(entry => {
                entry.classList.remove('selected-player');
                if (selectedPlayer) {
                    const playerNameElement = entry.querySelector('.player-name');
                    if (playerNameElement && playerNameElement.textContent.includes(selectedPlayer)) {
                        entry.classList.add('selected-player');
                    }
                }
            });
        }

        // æ›´æ–°å•ä¸ªç©å®¶çš„æ¸¸æˆç”»é¢
        function updateSinglePlayerView(playerName, gameState) {
            if (currentViewingPlayer !== playerName) return;

            const canvas = document.getElementById('singlePlayerCanvas');
            const statsElement = document.getElementById('viewingPlayerStats');

            if (!canvas || !gameState) return;

            // æ›´æ–°åŸå§‹æ¸¸æˆçŠ¶æ€
            updatePlayerStateForSmoothing(playerName, gameState);

            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ï¼ˆä½¿ç”¨åŸå§‹çŠ¶æ€ï¼‰
            const isOnline = gameState.timestamp && (Date.now() - gameState.timestamp < 10000);
            statsElement.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 14px;">
                    <div>ğŸ¯ åˆ†æ•°: ${gameState.s || 0}</div>
                    <div>âš¡ é€Ÿåº¦: ${gameState.gs || 0}</div>
                    <div>ğŸƒ è·³è·ƒ: ${gameState.p && gameState.p.j ? 'æ˜¯' : 'å¦'}</div>
                    <div>ğŸš§ éšœç¢ç‰©: ${gameState.o ? gameState.o.length : 0}</div>
                    <div>ğŸ’ é“å…·: ${gameState.pu ? gameState.pu.length : 0}</div>
                    <div>ğŸ›¡ï¸ æ— æ•Œ: ${gameState.i ? 'æ˜¯' : 'å¦'}</div>
                    <div>ğŸ® è¿è¡Œ: ${gameState.r ? 'æ˜¯' : 'å¦'}</div>
                    <div>ğŸ“¡ çŠ¶æ€: <span style="color: ${isOnline ? '#28a745' : '#dc3545'}">${isOnline ? 'åœ¨çº¿' : 'ç¦»çº¿'}</span></div>
                    <div>ğŸ¬ å¹³æ»‘: <span style="color: #007bff">å¯ç”¨</span></div>
                </div>
            `;

            // å¯åŠ¨å¹³æ»‘æ¸²æŸ“ï¼ˆå¦‚æœè¿˜æ²¡æœ‰å¯åŠ¨ï¼‰
            if (!smoothingAnimationId) {
                startSmoothingAnimation();
            }
        }

        // æ›´æ–°ç©å®¶çŠ¶æ€ç”¨äºå¹³æ»‘å¤„ç†
        function updatePlayerStateForSmoothing(playerName, newState) {
            // ä¿å­˜ä¸Šä¸€å¸§çŠ¶æ€
            if (smoothedStates.has(playerName)) {
                previousStates.set(playerName, JSON.parse(JSON.stringify(smoothedStates.get(playerName))));
            } else {
                // ç¬¬ä¸€æ¬¡æ¥æ”¶çŠ¶æ€ï¼Œç›´æ¥è®¾ç½®ä¸ºç›®æ ‡çŠ¶æ€
                previousStates.set(playerName, JSON.parse(JSON.stringify(newState)));
            }

            // è®¾ç½®ç›®æ ‡çŠ¶æ€
            allPlayersStates.set(playerName, newState);

            // å¦‚æœæ²¡æœ‰å¹³æ»‘çŠ¶æ€ï¼Œåˆå§‹åŒ–ä¸ºå½“å‰çŠ¶æ€
            if (!smoothedStates.has(playerName)) {
                smoothedStates.set(playerName, JSON.parse(JSON.stringify(newState)));
            }
        }

        // å¯åŠ¨å¹³æ»‘åŠ¨ç”»
        function startSmoothingAnimation() {
            function animate() {
                if (currentViewingPlayer) {
                    // æ›´æ–°å¹³æ»‘çŠ¶æ€
                    updateSmoothedState(currentViewingPlayer);

                    // ä½¿ç”¨å¹³æ»‘åçš„çŠ¶æ€ç»˜åˆ¶ç”»é¢
                    const smoothedState = smoothedStates.get(currentViewingPlayer);
                    if (smoothedState) {
                        drawPlayerGameState('singlePlayerCanvas', smoothedState, 1.0);
                    }
                }

                smoothingAnimationId = requestAnimationFrame(animate);
            }

            smoothingAnimationId = requestAnimationFrame(animate);
            console.log("View smoothing animation started");
        }

        // åœæ­¢å¹³æ»‘åŠ¨ç”»
        function stopSmoothingAnimation() {
            if (smoothingAnimationId) {
                cancelAnimationFrame(smoothingAnimationId);
                smoothingAnimationId = null;
                console.log("View smoothing animation stopped");
            }
        }

        // æ›´æ–°å¹³æ»‘çŠ¶æ€
        function updateSmoothedState(playerName) {
            const targetState = allPlayersStates.get(playerName);
            const currentSmoothed = smoothedStates.get(playerName);

            if (!targetState || !currentSmoothed) return;

            // åˆ›å»ºæ–°çš„å¹³æ»‘çŠ¶æ€
            const newSmoothed = JSON.parse(JSON.stringify(currentSmoothed));

            // å¹³æ»‘ç©å®¶ä½ç½®
            if (targetState.p && currentSmoothed.p) {
                if (smoothingEnabled) {
                    newSmoothed.p.x = lerp(currentSmoothed.p.x, targetState.p.x, smoothingFactor);
                    newSmoothed.p.y = lerp(currentSmoothed.p.y, targetState.p.y, smoothingFactor);
                    newSmoothed.p.vY = lerp(currentSmoothed.p.vY || 0, targetState.p.vY || 0, smoothingFactor);
                } else {
                    // å¹³æ»‘å…³é—­æ—¶ç›´æ¥ä½¿ç”¨ç›®æ ‡å€¼
                    newSmoothed.p.x = targetState.p.x;
                    newSmoothed.p.y = targetState.p.y;
                    newSmoothed.p.vY = targetState.p.vY;
                }

                // è·³è·ƒçŠ¶æ€ä¸éœ€è¦å¹³æ»‘ï¼Œç›´æ¥ä½¿ç”¨ç›®æ ‡å€¼
                newSmoothed.p.j = targetState.p.j;
            }

            // å¹³æ»‘åœ°é¢åç§»
            if (typeof targetState.go === 'number' && typeof currentSmoothed.go === 'number') {
                if (smoothingEnabled) {
                    newSmoothed.go = lerp(currentSmoothed.go, targetState.go, smoothingFactor);
                } else {
                    newSmoothed.go = targetState.go;
                }
            }

            // å¹³æ»‘éšœç¢ç‰©ä½ç½®
            if (targetState.o && currentSmoothed.o) {
                newSmoothed.o = smoothObstacles(currentSmoothed.o, targetState.o);
            } else if (targetState.o) {
                newSmoothed.o = targetState.o; // æ–°éšœç¢ç‰©ç›´æ¥ä½¿ç”¨ç›®æ ‡ä½ç½®
            }

            // å¹³æ»‘é“å…·ä½ç½®
            if (targetState.pu && currentSmoothed.pu) {
                newSmoothed.pu = smoothPowerups(currentSmoothed.pu, targetState.pu);
            } else if (targetState.pu) {
                newSmoothed.pu = targetState.pu; // æ–°é“å…·ç›´æ¥ä½¿ç”¨ç›®æ ‡ä½ç½®
            }

            // å…¶ä»–çŠ¶æ€ç›´æ¥ä½¿ç”¨ç›®æ ‡å€¼ï¼ˆä¸éœ€è¦å¹³æ»‘ï¼‰
            newSmoothed.s = targetState.s; // åˆ†æ•°
            newSmoothed.gs = targetState.gs; // æ¸¸æˆé€Ÿåº¦
            newSmoothed.i = targetState.i; // æ— æ•ŒçŠ¶æ€
            newSmoothed.r = targetState.r; // è¿è¡ŒçŠ¶æ€
            newSmoothed.timestamp = targetState.timestamp; // æ—¶é—´æˆ³

            // æ›´æ–°å¹³æ»‘çŠ¶æ€
            smoothedStates.set(playerName, newSmoothed);
        }

        // çº¿æ€§æ’å€¼å‡½æ•°
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        // å¹³æ»‘éšœç¢ç‰©ä½ç½®
        function smoothObstacles(currentObstacles, targetObstacles) {
            const smoothed = [];

            // å¯¹äºæ¯ä¸ªç›®æ ‡éšœç¢ç‰©ï¼Œå°è¯•æ‰¾åˆ°å¯¹åº”çš„å½“å‰éšœç¢ç‰©è¿›è¡Œå¹³æ»‘
            targetObstacles.forEach((targetObs, index) => {
                if (currentObstacles[index] &&
                    currentObstacles[index].t === targetObs.t &&
                    Math.abs(currentObstacles[index].x - targetObs.x) < 100) {
                    // å¦‚æœç±»å‹ç›¸åŒä¸”ä½ç½®ç›¸è¿‘ï¼Œè¿›è¡Œå¹³æ»‘
                    smoothed.push({
                        x: smoothingEnabled ? lerp(currentObstacles[index].x, targetObs.x, smoothingFactor) : targetObs.x,
                        y: targetObs.y, // Yä½ç½®é€šå¸¸ä¸å˜
                        w: targetObs.w, // å®½åº¦ä¸å˜
                        h: targetObs.h, // é«˜åº¦ä¸å˜
                        t: targetObs.t  // ç±»å‹ä¸å˜
                    });
                } else {
                    // æ–°éšœç¢ç‰©æˆ–ä½ç½®å·®å¼‚å¤ªå¤§ï¼Œç›´æ¥ä½¿ç”¨ç›®æ ‡ä½ç½®
                    smoothed.push(targetObs);
                }
            });

            return smoothed;
        }

        // å¹³æ»‘é“å…·ä½ç½®
        function smoothPowerups(currentPowerups, targetPowerups) {
            const smoothed = [];

            // å¯¹äºæ¯ä¸ªç›®æ ‡é“å…·ï¼Œå°è¯•æ‰¾åˆ°å¯¹åº”çš„å½“å‰é“å…·è¿›è¡Œå¹³æ»‘
            targetPowerups.forEach((targetPu, index) => {
                if (currentPowerups[index] &&
                    Math.abs(currentPowerups[index].x - targetPu.x) < 50) {
                    // å¦‚æœä½ç½®ç›¸è¿‘ï¼Œè¿›è¡Œå¹³æ»‘
                    smoothed.push({
                        x: smoothingEnabled ? lerp(currentPowerups[index].x, targetPu.x, smoothingFactor) : targetPu.x,
                        y: smoothingEnabled ? lerp(currentPowerups[index].y, targetPu.y, smoothingFactor) : targetPu.y
                    });
                } else {
                    // æ–°é“å…·æˆ–ä½ç½®å·®å¼‚å¤ªå¤§ï¼Œç›´æ¥ä½¿ç”¨ç›®æ ‡ä½ç½®
                    smoothed.push(targetPu);
                }
            });

            return smoothed;
        }

        // æ›´æ–°å¹³æ»‘å› å­
        function updateSmoothingFactor(value) {
            smoothingFactor = parseFloat(value);
            document.getElementById('smoothingValue').textContent = value;
            console.log(`Smoothing factor updated to: ${smoothingFactor}`);
        }

        // åˆ‡æ¢å¹³æ»‘å¼€å…³
        function toggleSmoothing() {
            smoothingEnabled = !smoothingEnabled;
            const btn = document.getElementById('toggleSmoothingBtn');
            const slider = document.getElementById('smoothingSlider');

            if (smoothingEnabled) {
                btn.textContent = 'ğŸ¬ å¹³æ»‘: å¼€';
                btn.classList.remove('disabled');
                slider.disabled = false;
                console.log('View smoothing enabled');
            } else {
                btn.textContent = 'ğŸ¬ å¹³æ»‘: å…³';
                btn.classList.add('disabled');
                slider.disabled = true;
                console.log('View smoothing disabled');
            }
        }

        // ç»˜åˆ¶å•ä¸ªç©å®¶çš„æ¸¸æˆçŠ¶æ€
        function drawPlayerGameState(canvasId, gameState, customScale = null) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // ç»˜åˆ¶èƒŒæ™¯æ¸å˜
            const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#98FB98');
            gradient.addColorStop(1, '#228B22');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
            let scaleX, scaleY;
            if (customScale !== null) {
                // ä½¿ç”¨è‡ªå®šä¹‰ç¼©æ”¾ï¼ˆç”¨äºå¤§ç”»é¢æ˜¾ç¤ºï¼‰
                scaleX = customScale;
                scaleY = customScale * (canvasHeight / 400); // ä¿æŒæ¯”ä¾‹
            } else {
                // è‡ªåŠ¨è®¡ç®—ç¼©æ”¾ï¼ˆç”¨äºè¿·ä½ ç”»é¢ï¼‰
                scaleX = canvasWidth / 800;
                scaleY = canvasHeight / 400;
            }

            // ç»˜åˆ¶èƒŒæ™¯äº‘æœµ
            drawMiniClouds(ctx, canvasWidth, canvasHeight, scaleX);

            // ç»˜åˆ¶åœ°é¢
            drawMiniGround(ctx, canvasWidth, canvasHeight, gameState.go || 0, scaleX);

            // ç»˜åˆ¶éšœç¢ç‰©ï¼ˆåœ¨ç©å®¶åé¢ï¼‰
            if (gameState.o && gameState.o.length > 0) {
                gameState.o.forEach(obstacle => {
                    drawMiniObstacle(ctx, obstacle, scaleX, scaleY);
                });
            }

            // ç»˜åˆ¶é“å…·
            if (gameState.pu && gameState.pu.length > 0) {
                gameState.pu.forEach(powerup => {
                    drawMiniPowerup(ctx, powerup, scaleX, scaleY);
                });
            }

            // ç»˜åˆ¶ç©å®¶ï¼ˆåœ¨æœ€å‰é¢ï¼‰
            if (gameState.p) {
                drawMiniPlayer(ctx, gameState.p, scaleX, scaleY);
            }

            // ç»˜åˆ¶UIå…ƒç´ 
            drawMiniUI(ctx, canvasWidth, canvasHeight, gameState);
        }



        // ç»˜åˆ¶è¿·ä½ åœ°é¢
        function drawMiniGround(ctx, canvasWidth, canvasHeight, groundOffset, scaleX) {
            const groundY = canvasHeight - 20; // ç›¸å¯¹äº150é«˜åº¦çš„åœ°é¢ä½ç½®

            // ç»˜åˆ¶åœ°é¢åŸºç¡€
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, groundY, canvasWidth, 20);

            // ç»˜åˆ¶åœ°é¢çº¹ç†
            ctx.fillStyle = '#32CD32';
            const grassSpacing = 20 * scaleX;
            for (let x = -(groundOffset * scaleX) % grassSpacing; x < canvasWidth; x += grassSpacing) {
                ctx.fillRect(x, groundY, 2, 20);
                // æ·»åŠ å°è‰æ•ˆæœ
                ctx.fillRect(x + 5, groundY, 1, 15);
                ctx.fillRect(x + 10, groundY, 1, 18);
                ctx.fillRect(x + 15, groundY, 1, 12);
            }

            // ç»˜åˆ¶åœ°é¢é˜´å½±
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, groundY, canvasWidth, 3);
        }

        // ç»˜åˆ¶è¿·ä½ ç©å®¶
        function drawMiniPlayer(ctx, playerState, scaleX, scaleY) {
            const x = playerState.x * scaleX;
            const y = playerState.y * scaleY;
            const width = 36; // æ”¾å¤§åˆ°åŸæ¥çš„ä¸‰å€ (12 * 3)
            const height = 36; // æ”¾å¤§åˆ°åŸæ¥çš„ä¸‰å€ (12 * 3)

            // ç»˜åˆ¶ç©å®¶é˜´å½±ï¼ˆæ”¾å¤§ï¼‰
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(x + 3, y + height - 6, width, 9);

            // å°è¯•ä½¿ç”¨åŠ è½½çš„ç©å®¶å›¾ç‰‡
            if (typeof player !== 'undefined' && player.image && player.imageLoaded) {
                try {
                    ctx.drawImage(player.image, x, y, width, height);
                } catch (error) {
                    // å¦‚æœå›¾ç‰‡ç»˜åˆ¶å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ç»˜åˆ¶
                    drawDefaultMiniPlayer(ctx, x, y, width, height, playerState);
                }
            } else {
                // ä½¿ç”¨é»˜è®¤ç»˜åˆ¶
                drawDefaultMiniPlayer(ctx, x, y, width, height, playerState);
            }

            // å¦‚æœåœ¨è·³è·ƒï¼Œæ·»åŠ è·³è·ƒç‰¹æ•ˆ
            if (playerState.j) {
                // è·³è·ƒå…‰ç¯ï¼ˆæ”¾å¤§ï¼‰
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(x - 6, y - 12, width + 12, 6);

                // è·³è·ƒç²’å­æ•ˆæœï¼ˆå¢åŠ æ•°é‡å’Œå¤§å°ï¼‰
                ctx.fillStyle = '#FFA500';
                for (let i = 0; i < 6; i++) {
                    const particleX = x + Math.random() * width;
                    const particleY = y + height + Math.random() * 15;
                    ctx.fillRect(particleX, particleY, 3, 3);
                }
            }

            // å¦‚æœé€Ÿåº¦è¾ƒå¿«ï¼Œæ·»åŠ ç§»åŠ¨çº¿æ¡
            if (playerState.vY !== 0) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x - 9, y + height/2);
                ctx.lineTo(x, y + height/2);
                ctx.stroke();
            }
        }

        // é»˜è®¤çš„è¿·ä½ ç©å®¶ç»˜åˆ¶
        function drawDefaultMiniPlayer(ctx, x, y, width, height, playerState) {
            // ç»˜åˆ¶ç©å®¶èº«ä½“
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(x, y, width, height);

            // ç»˜åˆ¶ç©å®¶å¤´éƒ¨ï¼ˆæ”¾å¤§ï¼‰
            ctx.fillStyle = '#FF8E8E';
            ctx.fillRect(x + 6, y, width - 12, 12);

            // ç»˜åˆ¶çœ¼ç›ï¼ˆæ”¾å¤§ï¼‰
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 9, y + 3, 3, 3);
            ctx.fillRect(x + width - 12, y + 3, 3, 3);

            // ç»˜åˆ¶æ‰‹è‡‚ï¼ˆæ”¾å¤§ï¼‰
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(x - 3, y + 12, 6, 12);
            ctx.fillRect(x + width - 3, y + 12, 6, 12);

            // ç»˜åˆ¶è…¿éƒ¨ï¼ˆæ”¾å¤§ï¼‰
            ctx.fillRect(x + 6, y + height - 6, 9, 6);
            ctx.fillRect(x + width - 15, y + height - 6, 9, 6);
        }

        // ç»˜åˆ¶è¿·ä½ éšœç¢ç‰©
        function drawMiniObstacle(ctx, obstacle, scaleX, scaleY) {
            const x = obstacle.x * scaleX;
            const y = obstacle.y * scaleY;
            const width = obstacle.w * scaleX;
            const height = obstacle.h * scaleY;

            // ç»˜åˆ¶é˜´å½±
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(x + 1, y + height - 1, width, 2);

            switch(obstacle.t) {
                case 0: // æ æ†
                    drawMiniBarrier(ctx, x, y, width, height);
                    break;
                case 1: // çŸ³å¤´
                    drawMiniRock(ctx, x, y, width, height);
                    break;
                case 2: // æ ‘
                    drawMiniTree(ctx, x, y, width, height);
                    break;
                case 3: // æˆ¿å­
                    drawMiniHouse(ctx, x, y, width, height);
                    break;
                default:
                    // é»˜è®¤éšœç¢ç‰©
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x, y, width, height);
            }
        }

        // ç»˜åˆ¶æ æ†
        function drawMiniBarrier(ctx, x, y, width, height) {
            // æ æ†æŸ±å­
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x, y, 2, height);
            ctx.fillRect(x + width - 2, y, 2, height);

            // æ æ†æ¨ªæ¡
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(x, y + height * 0.3, width, 2);
            ctx.fillRect(x, y + height * 0.6, width, 2);

            // é‡‘å±å…‰æ³½
            ctx.fillStyle = '#D2B48C';
            ctx.fillRect(x, y, 1, height);
            ctx.fillRect(x + width - 1, y, 1, height);
        }

        // ç»˜åˆ¶çŸ³å¤´
        function drawMiniRock(ctx, x, y, width, height) {
            // ä¸»ä½“
            ctx.fillStyle = '#696969';
            ctx.fillRect(x, y, width, height);

            // çŸ³å¤´çº¹ç†
            ctx.fillStyle = '#808080';
            ctx.fillRect(x + 1, y + 1, width - 2, 2);
            ctx.fillRect(x + 2, y + height - 3, width - 4, 2);

            // é«˜å…‰
            ctx.fillStyle = '#A9A9A9';
            ctx.fillRect(x, y, 2, 2);

            // è£‚çº¹
            ctx.fillStyle = '#2F4F4F';
            ctx.fillRect(x + width/2, y + 2, 1, height - 4);
        }

        // ç»˜åˆ¶æ ‘
        function drawMiniTree(ctx, x, y, width, height) {
            // æ ‘å¹²
            ctx.fillStyle = '#8B4513';
            const trunkWidth = Math.max(2, width * 0.3);
            const trunkX = x + (width - trunkWidth) / 2;
            ctx.fillRect(trunkX, y + height * 0.6, trunkWidth, height * 0.4);

            // æ ‘å¶
            ctx.fillStyle = '#228B22';
            ctx.fillRect(x, y, width, height * 0.7);

            // æ ‘å¶å±‚æ¬¡
            ctx.fillStyle = '#32CD32';
            ctx.fillRect(x + 1, y + 1, width - 2, height * 0.3);

            // æ ‘å¹²çº¹ç†
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(trunkX, y + height * 0.7, 1, height * 0.3);
        }

        // ç»˜åˆ¶æˆ¿å­
        function drawMiniHouse(ctx, x, y, width, height) {
            // æˆ¿å­ä¸»ä½“
            ctx.fillStyle = '#CD853F';
            ctx.fillRect(x, y + height * 0.3, width, height * 0.7);

            // å±‹é¡¶
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(x - 1, y, width + 2, height * 0.4);

            // é—¨
            ctx.fillStyle = '#654321';
            const doorWidth = Math.max(2, width * 0.3);
            ctx.fillRect(x + (width - doorWidth) / 2, y + height * 0.5, doorWidth, height * 0.5);

            // çª—æˆ·
            ctx.fillStyle = '#87CEEB';
            const windowSize = Math.max(1, width * 0.15);
            ctx.fillRect(x + 2, y + height * 0.4, windowSize, windowSize);
            ctx.fillRect(x + width - windowSize - 2, y + height * 0.4, windowSize, windowSize);

            // å±‹é¡¶é«˜å…‰
            ctx.fillStyle = '#DC143C';
            ctx.fillRect(x, y, width, 2);
        }

        // ç»˜åˆ¶è¿·ä½ é“å…·
        function drawMiniPowerup(ctx, powerup, scaleX, scaleY) {
            const x = powerup.x * scaleX;
            const y = powerup.y * scaleY;
            const size = 8; // å›ºå®šçš„é“å…·å¤§å°
            const centerX = x + size/2;
            const centerY = y + size/2;
            const radius = size/2;

            // ç»˜åˆ¶é‡‘å¸é˜´å½±
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(centerX + 1, centerY + 1, radius, 0, Math.PI * 2);
            ctx.fill();

            // å°è¯•ä½¿ç”¨åŠ è½½çš„é‡‘å¸å›¾ç‰‡
            if (typeof coinImage !== 'undefined' && coinImage.image && coinImage.imageLoaded) {
                try {
                    ctx.drawImage(coinImage.image, x, y, size, size);
                } catch (error) {
                    // å¦‚æœå›¾ç‰‡ç»˜åˆ¶å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ç»˜åˆ¶
                    drawDefaultMiniCoin(ctx, centerX, centerY, radius);
                }
            } else {
                // ä½¿ç”¨é»˜è®¤ç»˜åˆ¶
                drawDefaultMiniCoin(ctx, centerX, centerY, radius);
            }

            // æ·»åŠ é—ªçƒæ•ˆæœï¼ˆåŸºäºæ—¶é—´çš„ç®€å•åŠ¨ç”»ï¼‰
            const time = Date.now() * 0.01;
            const sparkle = Math.sin(time) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 255, 255, ${sparkle * 0.3})`;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        // é»˜è®¤çš„è¿·ä½ é‡‘å¸ç»˜åˆ¶
        function drawDefaultMiniCoin(ctx, centerX, centerY, radius) {
            // ç»˜åˆ¶é‡‘å¸ä¸»ä½“
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶é‡‘å¸å†…åœˆ
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.7, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶é‡‘å¸ä¸­å¿ƒ
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶é«˜å…‰
            ctx.fillStyle = '#FFFF99';
            ctx.beginPath();
            ctx.arc(centerX - radius * 0.3, centerY - radius * 0.3, radius * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶é‡‘å¸è¾¹ç¼˜
            ctx.strokeStyle = '#B8860B';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // ç»˜åˆ¶è¿·ä½ äº‘æœµ
        function drawMiniClouds(ctx, canvasWidth, canvasHeight, scaleX) {
            // ç»˜åˆ¶å‡ æœµç®€å•çš„äº‘æœµä½œä¸ºèƒŒæ™¯
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';

            // äº‘æœµ1
            drawMiniCloud(ctx, canvasWidth * 0.2, canvasHeight * 0.2, 15 * scaleX);

            // äº‘æœµ2
            drawMiniCloud(ctx, canvasWidth * 0.7, canvasHeight * 0.15, 12 * scaleX);

            // äº‘æœµ3
            drawMiniCloud(ctx, canvasWidth * 0.5, canvasHeight * 0.25, 10 * scaleX);
        }

        // ç»˜åˆ¶å•ä¸ªäº‘æœµ
        function drawMiniCloud(ctx, x, y, size) {
            ctx.beginPath();
            // äº‘æœµä¸»ä½“
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.arc(x + size * 0.8, y, size * 0.8, 0, Math.PI * 2);
            ctx.arc(x + size * 1.6, y, size, 0, Math.PI * 2);
            ctx.arc(x + size * 0.8, y - size * 0.5, size * 0.6, 0, Math.PI * 2);
            ctx.fill();
        }

        // ç»˜åˆ¶è¿·ä½ UIå…ƒç´ 
        function drawMiniUI(ctx, canvasWidth, canvasHeight, gameState) {
            // ç»˜åˆ¶åˆ†æ•°æ˜¾ç¤º
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(5, 5, 60, 15);

            ctx.fillStyle = '#FFFFFF';
            ctx.font = '10px Arial';
            ctx.fillText(`åˆ†æ•°: ${gameState.s || 0}`, 8, 15);

            // ç»˜åˆ¶é€Ÿåº¦æŒ‡ç¤ºå™¨
            if (gameState.gs > 3) {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.8)';
                ctx.fillRect(canvasWidth - 25, 5, 20, 3);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '8px Arial';
                ctx.fillText('å¿«', canvasWidth - 22, 14);
            }

            // ç»˜åˆ¶æ— æ•ŒçŠ¶æ€æŒ‡ç¤º
            if (gameState.i) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.fillRect(canvasWidth - 50, 5, 20, 15);
                ctx.fillStyle = '#000000';
                ctx.font = '8px Arial';
                ctx.fillText('æ— æ•Œ', canvasWidth - 47, 15);
            }

            // ç»˜åˆ¶è·³è·ƒçŠ¶æ€æŒ‡ç¤º
            if (gameState.p && gameState.p.j) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
                ctx.fillRect(5, canvasHeight - 20, 30, 15);
                ctx.fillStyle = '#000000';
                ctx.font = '8px Arial';
                ctx.fillText('è·³è·ƒ', 8, canvasHeight - 10);
            }

            // ç»˜åˆ¶æ¸¸æˆçŠ¶æ€æŒ‡ç¤º
            if (!gameState.r) {
                // æ¸¸æˆæš‚åœæˆ–ç»“æŸ
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(canvasWidth/2 - 25, canvasHeight/2 - 10, 50, 20);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æš‚åœ', canvasWidth/2, canvasHeight/2 + 2);
                ctx.textAlign = 'left'; // é‡ç½®å¯¹é½
            }
        }

        // æ˜¾ç¤ºç©ºæ’è¡Œæ¦œï¼ˆä»…åœ¨æœªè¿æ¥æ—¶ï¼‰
        function showEmptyLeaderboard() {
            updateLeaderboardDisplay([]);
            if (leaderboardContentElement) {
                leaderboardContentElement.innerHTML = '<div class="no-data">è¯·è¿æ¥åˆ°MultiSYNQä»¥æŸ¥çœ‹æ’è¡Œæ¦œ</div>';
            }
            if (lastUpdatedElement) {
                lastUpdatedElement.textContent = 'ç­‰å¾…è¿æ¥åˆ°MultiSYNQ...';
            }
        }

        // åŠ è½½ç©å®¶å›¾ç‰‡
        function loadPlayerImage() {
            player.image = new Image();
            player.image.onload = function () {
                player.imageLoaded = true;
                console.log('ç©å®¶å›¾ç‰‡åŠ è½½æˆåŠŸ');
            };
            player.image.onerror = function () {
                console.log('ç©å®¶å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ç»˜åˆ¶');
                player.imageLoaded = false;
            };
            // ä½ å¯ä»¥å°†è¿™é‡Œçš„è·¯å¾„æ”¹ä¸ºä½ çš„PNGå›¾ç‰‡è·¯å¾„
            player.image.src = 'horse1.png'; // è¯·ç¡®ä¿è¿™ä¸ªæ–‡ä»¶å­˜åœ¨äºåŒä¸€ç›®å½•ä¸‹
        }

        // åŠ è½½é‡‘å¸å›¾ç‰‡
        function loadCoinImage() {
            coinImage.image = new Image();
            coinImage.image.onload = function () {
                coinImage.imageLoaded = true;
                console.log('é‡‘å¸å›¾ç‰‡åŠ è½½æˆåŠŸ');
            };
            coinImage.image.onerror = function () {
                console.log('é‡‘å¸å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ç»˜åˆ¶');
                coinImage.imageLoaded = false;
            };
            // ä½ å¯ä»¥å°†è¿™é‡Œçš„è·¯å¾„æ”¹ä¸ºä½ çš„JPGå›¾ç‰‡è·¯å¾„
            coinImage.image.src = 'mon.png'; // è¯·ç¡®ä¿è¿™ä¸ªæ–‡ä»¶å­˜åœ¨äºåŒä¸€ç›®å½•ä¸‹
        }

        // åŠ è½½æœ€é«˜å¾—åˆ†
        function loadHighScore() {
            const savedHighScore = localStorage.getItem('jumpGameHighScore');
            if (savedHighScore) {
                highScore = parseInt(savedHighScore);
            }
            updateHighScoreDisplay();
        }

        // ä¿å­˜æœ€é«˜å¾—åˆ†
        function saveHighScore() {
            localStorage.setItem('jumpGameHighScore', highScore.toString());
        }

        // æ›´æ–°æœ€é«˜å¾—åˆ†æ˜¾ç¤º
        function updateHighScoreDisplay() {
            highScoreElement.textContent = `æœ€é«˜å¾—åˆ†: ${highScore}`;
        }

        // æ£€æŸ¥å¹¶æ›´æ–°æœ€é«˜å¾—åˆ†
        function checkHighScore() {
            if (score > highScore) {
                highScore = score;
                saveHighScore();
                updateHighScoreDisplay();
                return true; // è¿”å›trueè¡¨ç¤ºåˆ›é€ äº†æ–°çºªå½•
            }
            return false;
        }

        // éšœç¢ç‰©æ•°ç»„
        let obstacles = [];

        // äº‘æœµæ•°ç»„
        let clouds = [];

        // é“å…·æ•°ç»„
        let powerups = [];

        // æ— æ•ŒçŠ¶æ€
        let invincible = false;
        let invincibleTime = 0;
        const INVINCIBLE_DURATION = 600; // 10ç§’ (60fps * 10)

        // åœ°é¢æ»šåŠ¨åç§»
        let groundOffset = 0;

        // åˆå§‹åŒ–äº‘æœµ
        function initClouds() {
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * 100 + 20,
                    width: 60 + Math.random() * 40,
                    height: 30 + Math.random() * 20,
                    speed: 0.5 + Math.random() * 0.5
                });
            }
        }

        // ç»˜åˆ¶ç©å®¶è§’è‰²
        function drawPlayer() {
            // ç»˜åˆ¶ç©å®¶é˜´å½±
            drawPlayerShadow();

            // ç»˜åˆ¶é€Ÿåº¦çº¿æ¡ï¼ˆåœ¨ç©å®¶åé¢ï¼‰
            drawPlayerSpeedLines();

            if (player.imageLoaded && player.image) {
                // ä½¿ç”¨PNGå›¾ç‰‡ç»˜åˆ¶ç©å®¶
                ctx.save();

                // æ— æ•ŒçŠ¶æ€ä¸‹æ·»åŠ é—ªçƒæ•ˆæœ
                if (invincible && Math.floor(frameCount / 5) % 2 === 0) {
                    ctx.globalAlpha = 0.5; // åŠé€æ˜é—ªçƒæ•ˆæœ
                    ctx.filter = 'hue-rotate(180deg)'; // è‰²è°ƒå˜åŒ–
                }

                // ç»˜åˆ¶ç©å®¶å›¾ç‰‡
                ctx.drawImage(player.image, player.x, player.y, player.width, player.height);

                ctx.restore();
            } else {
                // å›¾ç‰‡æœªåŠ è½½æ—¶ä½¿ç”¨åŸæ¥çš„åƒç´ åŒ–ç»˜åˆ¶æ–¹å¼
                // æ— æ•ŒçŠ¶æ€ä¸‹è§’è‰²é—ªçƒ
                if (invincible && Math.floor(frameCount / 5) % 2 === 0) {
                    ctx.fillStyle = '#FFB6C1'; // ç²‰è‰²é—ªçƒ
                } else {
                    ctx.fillStyle = player.color;
                }
                ctx.fillRect(player.x, player.y, player.width, player.height);

                // ç»˜åˆ¶ç®€å•çš„åƒç´ çœ¼ç›
                ctx.fillStyle = '#000';
                ctx.fillRect(player.x + 8, player.y + 8, 4, 4);
                ctx.fillRect(player.x + 20, player.y + 8, 4, 4);

                // ç»˜åˆ¶åƒç´ å˜´å·´
                ctx.fillRect(player.x + 12, player.y + 20, 8, 2);
            }

            // ç»˜åˆ¶è·³è·ƒç‰¹æ•ˆï¼ˆåœ¨ç©å®¶å‰é¢ï¼‰
            drawPlayerJumpEffects();

            // ç»˜åˆ¶æ— æ•ŒçŠ¶æ€çš„äº”è§’æ˜Ÿ
            if (invincible) {
                drawInvincibleStar();
            }
        }

        // ç»˜åˆ¶ç©å®¶é˜´å½±
        function drawPlayerShadow() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(player.x + 3, player.y + player.height - 2, player.width, 6);
        }

        // ç»˜åˆ¶ç©å®¶é€Ÿåº¦çº¿æ¡
        function drawPlayerSpeedLines() {
            // åªåœ¨ç§»åŠ¨æ—¶æ˜¾ç¤ºé€Ÿåº¦çº¿æ¡
            if (Math.abs(player.velocityY) > 1 || gameSpeed > BASE_GAME_SPEED) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
                ctx.lineWidth = 2;

                // ç»˜åˆ¶å¤šæ¡é€Ÿåº¦çº¿
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    const lineY = player.y + player.height/2 + (i - 1) * 8;
                    const lineLength = 15 + gameSpeed * 3;
                    ctx.moveTo(player.x - lineLength - i * 5, lineY);
                    ctx.lineTo(player.x - i * 5, lineY);
                    ctx.stroke();
                }
            }
        }

        // ç»˜åˆ¶ç©å®¶è·³è·ƒç‰¹æ•ˆ
        function drawPlayerJumpEffects() {
            if (player.isJumping) {
                // ç»˜åˆ¶è·³è·ƒå…‰ç¯
                drawJumpAura();

                // ç»˜åˆ¶è·³è·ƒç²’å­
                drawJumpParticles();
            }
        }

        // ç»˜åˆ¶è·³è·ƒå…‰ç¯
        function drawJumpAura() {
            const auraWidth = player.width + 16;
            const auraHeight = 8;
            const auraX = player.x - 8;
            const auraY = player.y - 15;

            // ä¸»å…‰ç¯
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(auraX, auraY, auraWidth, auraHeight);

            // å†…å±‚å…‰ç¯
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(auraX + 4, auraY + 2, auraWidth - 8, auraHeight - 4);

            // é—ªçƒæ•ˆæœ
            const time = Date.now() * 0.01;
            const sparkle = Math.sin(time * 2) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 255, 255, ${sparkle * 0.6})`;
            ctx.fillRect(auraX + 2, auraY + 1, auraWidth - 4, auraHeight - 2);
        }

        // ç»˜åˆ¶è·³è·ƒç²’å­
        function drawJumpParticles() {
            ctx.fillStyle = '#FFA500';

            // åœ¨ç©å®¶ä¸‹æ–¹ç”Ÿæˆç²’å­
            for (let i = 0; i < 8; i++) {
                const particleX = player.x + Math.random() * player.width;
                const particleY = player.y + player.height + Math.random() * 20;
                const particleSize = 2 + Math.random() * 3;

                // æ·»åŠ ä¸€äº›éšæœºæ€§è®©ç²’å­æ›´è‡ªç„¶
                const offsetX = (Math.random() - 0.5) * 10;
                const offsetY = Math.random() * 15;

                ctx.fillRect(particleX + offsetX, particleY + offsetY, particleSize, particleSize);
            }

            // æ·»åŠ ä¸€äº›ä¸Šå‡çš„ç²’å­
            ctx.fillStyle = '#FFD700';
            for (let i = 0; i < 4; i++) {
                const particleX = player.x + Math.random() * player.width;
                const particleY = player.y - Math.random() * 10;
                const particleSize = 1 + Math.random() * 2;

                ctx.fillRect(particleX, particleY, particleSize, particleSize);
            }
        }

        // ç»˜åˆ¶æ— æ•ŒçŠ¶æ€çš„äº”è§’æ˜Ÿ
        function drawInvincibleStar() {
            const starX = player.x + player.width / 2;
            const starY = player.y - 25;
            const timeLeft = INVINCIBLE_DURATION - invincibleTime;

            // æœ€å3ç§’é—ªçƒ (180å¸§)
            if (timeLeft <= 180 && Math.floor(frameCount / 10) % 2 === 0) {
                return; // è·³è¿‡ç»˜åˆ¶ï¼Œäº§ç”Ÿé—ªçƒæ•ˆæœ
            }

            // ç»˜åˆ¶æ–°çš„äº”è§’æ˜Ÿè®¾è®¡
            ctx.fillStyle = '#FFD700'; // é‡‘è‰²
            drawStarShape(starX, starY, 8); // åŠå¾„8åƒç´ çš„äº”è§’æ˜Ÿ
        }

        // ç»˜åˆ¶æ ‡å‡†äº”è§’æ˜Ÿå½¢çŠ¶çš„è¾…åŠ©å‡½æ•°
        function drawStarShape(centerX, centerY, radius) {
            // äº”è§’æ˜Ÿçš„5ä¸ªé¡¶ç‚¹åæ ‡ï¼ˆåƒç´ åŒ–å¤„ç†ï¼‰
            const points = [];
            for (let i = 0; i < 5; i++) {
                // å¤–åœˆé¡¶ç‚¹
                const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                const x = Math.round(centerX + radius * Math.cos(angle));
                const y = Math.round(centerY + radius * Math.sin(angle));
                points.push({ x, y });

                // å†…åœˆé¡¶ç‚¹
                const innerAngle = ((i + 0.5) * 2 * Math.PI / 5) - Math.PI / 2;
                const innerRadius = radius * 0.4;
                const innerX = Math.round(centerX + innerRadius * Math.cos(innerAngle));
                const innerY = Math.round(centerY + innerRadius * Math.sin(innerAngle));
                points.push({ x: innerX, y: innerY });
            }

            // ä½¿ç”¨åƒç´ ç»˜åˆ¶äº”è§’æ˜Ÿè½®å»“å’Œå¡«å……
            // ç»˜åˆ¶äº”è§’æ˜Ÿçš„ä¸»ä½“ç»“æ„
            // é¡¶éƒ¨å°–è§’
            ctx.fillRect(centerX - 1, centerY - radius, 3, 3);
            ctx.fillRect(centerX, centerY - radius - 1, 1, 1);

            // å·¦ä¸Šè§’
            const leftTopX = Math.round(centerX - radius * 0.95);
            const leftTopY = Math.round(centerY - radius * 0.31);
            ctx.fillRect(leftTopX - 1, leftTopY - 1, 3, 3);

            // å³ä¸Šè§’
            const rightTopX = Math.round(centerX + radius * 0.95);
            const rightTopY = Math.round(centerY - radius * 0.31);
            ctx.fillRect(rightTopX - 1, rightTopY - 1, 3, 3);

            // å·¦ä¸‹è§’
            const leftBottomX = Math.round(centerX - radius * 0.59);
            const leftBottomY = Math.round(centerY + radius * 0.81);
            ctx.fillRect(leftBottomX - 1, leftBottomY - 1, 3, 3);

            // å³ä¸‹è§’
            const rightBottomX = Math.round(centerX + radius * 0.59);
            const rightBottomY = Math.round(centerY + radius * 0.81);
            ctx.fillRect(rightBottomX - 1, rightBottomY - 1, 3, 3);

            // å¡«å……ä¸­å¿ƒåŒºåŸŸ
            ctx.fillRect(centerX - 3, centerY - 2, 7, 5);
            ctx.fillRect(centerX - 2, centerY - 4, 5, 8);
            ctx.fillRect(centerX - 4, centerY, 9, 3);
        }

        // ç»˜åˆ¶éšœç¢ç‰©ï¼ˆå¤šç§ç±»å‹ï¼‰
        function drawObstacles() {
            obstacles.forEach(obstacle => {
                switch (obstacle.type) {
                    case 0: // æ æ†
                        drawFence(obstacle);
                        break;
                    case 1: // çŸ³å¤´
                        drawRock(obstacle);
                        break;
                    case 2: // å°æ ‘
                        drawTree(obstacle);
                        break;
                    case 3: // å°æˆ¿å­
                        drawHouse(obstacle);
                        break;
                }
            });
        }

        // ç»˜åˆ¶æ æ†
        function drawFence(obstacle) {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

            // ç»˜åˆ¶æ æ†æ¨ªæ¡
            ctx.fillStyle = '#654321';
            const barCount = Math.max(1, Math.floor(obstacle.height / 15));
            const barSpacing = obstacle.height / (barCount + 1);

            for (let i = 0; i < barCount; i++) {
                const barY = obstacle.y + barSpacing * (i + 1);
                ctx.fillRect(obstacle.x - 2, barY, obstacle.width + 4, 2);
            }
        }

        // ç»˜åˆ¶çŸ³å¤´ï¼ˆä¸‰ä¸ªæ¤­åœ†å †æˆä¸‰è§’å½¢ï¼‰
        function drawRock(obstacle) {
            // è®¡ç®—ä¸‰ä¸ªæ¤­åœ†çš„ä½ç½®å’Œå¤§å°
            const baseWidth = obstacle.width;
            const baseHeight = obstacle.height;

            // åº•éƒ¨ä¸¤ä¸ªæ¤­åœ†ï¼ˆå·¦å³ï¼‰
            const bottomLeftX = obstacle.x;
            const bottomRightX = obstacle.x + baseWidth * 0.6;
            const bottomY = obstacle.y + baseHeight * 0.5;
            const bottomWidth = baseWidth * 0.4;
            const bottomHeight = baseHeight * 0.5;

            // é¡¶éƒ¨æ¤­åœ†ï¼ˆä¸­é—´ï¼‰
            const topX = obstacle.x + baseWidth * 0.25;
            const topY = obstacle.y;
            const topWidth = baseWidth * 0.5;
            const topHeight = baseHeight * 0.6;

            // ç»˜åˆ¶åº•éƒ¨å·¦æ¤­åœ†
            drawEllipse(bottomLeftX, bottomY, bottomWidth, bottomHeight, '#696969');

            // ç»˜åˆ¶åº•éƒ¨å³æ¤­åœ†
            drawEllipse(bottomRightX, bottomY, bottomWidth, bottomHeight, '#696969');

            // ç»˜åˆ¶é¡¶éƒ¨æ¤­åœ†
            drawEllipse(topX, topY, topWidth, topHeight, '#777777');

            // æ·»åŠ é«˜å…‰æ•ˆæœ
            ctx.fillStyle = '#888888';
            // é¡¶éƒ¨æ¤­åœ†é«˜å…‰
            ctx.fillRect(topX + 2, topY + 2, Math.max(1, topWidth / 4), 2);
            // å·¦ä¸‹æ¤­åœ†é«˜å…‰
            ctx.fillRect(bottomLeftX + 1, bottomY + 1, Math.max(1, bottomWidth / 4), 1);

            // æ·»åŠ é˜´å½±æ•ˆæœ
            ctx.fillStyle = '#555555';
            // å³ä¸‹æ¤­åœ†é˜´å½±
            ctx.fillRect(bottomRightX + bottomWidth - 2, bottomY + bottomHeight - 2, 2, 2);
            // é¡¶éƒ¨æ¤­åœ†å³ä¾§é˜´å½±
            ctx.fillRect(topX + topWidth - 1, topY + topHeight - 3, 1, 3);
        }

        // è¾…åŠ©å‡½æ•°ï¼šç»˜åˆ¶æ¤­åœ†
        function drawEllipse(x, y, width, height, color) {
            ctx.fillStyle = color;
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            const radiusX = width / 2;
            const radiusY = height / 2;

            // ä½¿ç”¨åƒç´ é€è¡Œç»˜åˆ¶æ¤­åœ†
            for (let dy = -Math.floor(radiusY); dy <= Math.floor(radiusY); dy++) {
                const normalizedY = dy / radiusY;
                const xRange = Math.floor(radiusX * Math.sqrt(Math.max(0, 1 - normalizedY * normalizedY)));

                const currentY = Math.floor(centerY + dy);
                const startX = Math.floor(centerX - xRange);
                const endX = Math.floor(centerX + xRange);

                if (currentY >= y && currentY < y + height && xRange > 0) {
                    ctx.fillRect(Math.max(x, startX), currentY,
                        Math.min(x + width, endX) - Math.max(x, startX), 1);
                }
            }
        }

        // ç»˜åˆ¶å°æ ‘
        function drawTree(obstacle) {
            const trunkWidth = Math.max(3, obstacle.width / 3);
            const trunkX = obstacle.x + (obstacle.width - trunkWidth) / 2;
            const crownHeight = obstacle.height * 0.7;
            const trunkHeight = obstacle.height * 0.3;

            // æ ‘å¹²
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(trunkX, obstacle.y + crownHeight, trunkWidth, trunkHeight);

            // æ ‘å†  (åˆ†å±‚ç»˜åˆ¶)
            ctx.fillStyle = '#228B22';
            // åº•å±‚
            ctx.fillRect(obstacle.x, obstacle.y + crownHeight * 0.6, obstacle.width, crownHeight * 0.4);
            // ä¸­å±‚
            ctx.fillRect(obstacle.x + 1, obstacle.y + crownHeight * 0.3, obstacle.width - 2, crownHeight * 0.4);
            // é¡¶å±‚
            ctx.fillRect(obstacle.x + 2, obstacle.y, obstacle.width - 4, crownHeight * 0.4);

            // æ ‘å¶é«˜å…‰
            ctx.fillStyle = '#32CD32';
            ctx.fillRect(obstacle.x + 1, obstacle.y + 1, obstacle.width - 3, 2);
        }

        // ç»˜åˆ¶å°æˆ¿å­
        function drawHouse(obstacle) {
            const roofHeight = obstacle.height * 0.4;
            const wallHeight = obstacle.height * 0.6;

            // å¢™ä½“
            ctx.fillStyle = '#CD853F';
            ctx.fillRect(obstacle.x, obstacle.y + roofHeight, obstacle.width, wallHeight);

            // å±‹é¡¶
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(obstacle.x - 1, obstacle.y + roofHeight, obstacle.width + 2, 3);
            ctx.fillRect(obstacle.x, obstacle.y + roofHeight - 3, obstacle.width, 3);
            ctx.fillRect(obstacle.x + 1, obstacle.y, obstacle.width - 2, roofHeight);

            // é—¨
            if (obstacle.width >= 8) {
                ctx.fillStyle = '#654321';
                const doorWidth = Math.max(2, obstacle.width / 4);
                const doorX = obstacle.x + (obstacle.width - doorWidth) / 2;
                ctx.fillRect(doorX, obstacle.y + roofHeight + wallHeight * 0.3, doorWidth, wallHeight * 0.7);
            }

            // çª—æˆ·
            if (obstacle.width >= 10) {
                ctx.fillStyle = '#87CEEB';
                const windowSize = 2;
                ctx.fillRect(obstacle.x + 2, obstacle.y + roofHeight + 3, windowSize, windowSize);
                if (obstacle.width >= 12) {
                    ctx.fillRect(obstacle.x + obstacle.width - 4, obstacle.y + roofHeight + 3, windowSize, windowSize);
                }
            }
        }

        // ç»˜åˆ¶äº‘æœµ
        function drawClouds() {
            ctx.fillStyle = '#FFFFFF';
            clouds.forEach(cloud => {
                // ç»˜åˆ¶åƒç´ åŒ–äº‘æœµ
                ctx.fillRect(cloud.x, cloud.y, cloud.width, cloud.height);
                ctx.fillRect(cloud.x + 10, cloud.y - 8, cloud.width - 20, 16);
                ctx.fillRect(cloud.x + 20, cloud.y - 12, cloud.width - 40, 8);
            });
        }

        // ç»˜åˆ¶é“å…·
        function drawPowerups() {
            powerups.forEach(powerup => {
                if (powerup.type === 'coin') {
                    drawCoin(powerup);
                } else if (powerup.type === 'star') {
                    drawStar(powerup);
                }
            });
        }

        // ç»˜åˆ¶é‡‘å¸
        function drawCoin(coin) {
            if (coinImage.imageLoaded && coinImage.image) {
                // ä½¿ç”¨JPGå›¾ç‰‡ç»˜åˆ¶é‡‘å¸ï¼Œæ”¾å¤§2å€æ˜¾ç¤º
                ctx.save();

                // è®¡ç®—æ”¾å¤§2å€åçš„å°ºå¯¸
                const scaledWidth = coin.width * 2;
                const scaledHeight = coin.height * 2;

                // è°ƒæ•´ä½ç½®ä½¿é‡‘å¸å±…ä¸­æ˜¾ç¤ºï¼ˆé¿å…å› ä¸ºæ”¾å¤§è€Œåç§»ï¼‰
                const adjustedX = coin.x - coin.width / 2;
                const adjustedY = coin.y - coin.height / 2;

                // æ·»åŠ è½»å¾®çš„æµ®åŠ¨æ•ˆæœï¼ˆå¯é€‰ï¼‰
                const floatOffset = Math.sin(frameCount * 0.1) * 2;

                ctx.drawImage(coinImage.image,
                    adjustedX,
                    adjustedY + floatOffset,
                    scaledWidth,
                    scaledHeight);

                ctx.restore();
            } else {
                // å›¾ç‰‡æœªåŠ è½½æ—¶ä½¿ç”¨åŸæ¥çš„åƒç´ åŒ–ç»˜åˆ¶æ–¹å¼ï¼Œä¹Ÿæ”¾å¤§2å€
                const scaledWidth = coin.width * 2;
                const scaledHeight = coin.height * 2;
                const adjustedX = coin.x - coin.width / 2;
                const adjustedY = coin.y - coin.height / 2;

                ctx.fillStyle = '#FFD700'; // é‡‘è‰²
                // å¤–åœˆï¼ˆæ”¾å¤§2å€ï¼‰
                ctx.fillRect(adjustedX + 4, adjustedY, scaledWidth - 8, scaledHeight);
                ctx.fillRect(adjustedX, adjustedY + 4, scaledWidth, scaledHeight - 8);

                // å†…éƒ¨ç»†èŠ‚ï¼ˆæ”¾å¤§2å€ï¼‰
                ctx.fillStyle = '#FFA500'; // æ©™è‰²é˜´å½±
                ctx.fillRect(adjustedX + 8, adjustedY + 4, scaledWidth - 16, scaledHeight - 8);

                // ä¸­å¿ƒç¬¦å· ($)ï¼ˆæ”¾å¤§2å€ï¼‰
                ctx.fillStyle = '#B8860B'; // æ·±é‡‘è‰²
                ctx.fillRect(adjustedX + scaledWidth / 2 - 2, adjustedY + 4, 4, scaledHeight - 8);
                ctx.fillRect(adjustedX + 4, adjustedY + scaledHeight / 2 - 2, scaledWidth - 8, 4);
            }
        }

        // ç»˜åˆ¶äº”è§’æ˜Ÿé“å…·
        function drawStar(star) {
            ctx.fillStyle = '#FF69B4'; // ç²‰è‰²
            const centerX = star.x + star.width / 2;
            const centerY = star.y + star.height / 2;

            // ç»˜åˆ¶æ–°çš„äº”è§’æ˜Ÿè®¾è®¡ (é“å…·å¤§å°ä¸º16åƒç´ åŠå¾„)
            drawStarShape(centerX, centerY, 16);
        }

        // ç»˜åˆ¶æ»šåŠ¨åœ°é¢
        function drawGround() {
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, GROUND_Y + 32, canvas.width, 28);

            // ç»˜åˆ¶è‰åœ°çº¹ç†
            ctx.fillStyle = '#32CD32';
            for (let x = -groundOffset % 20; x < canvas.width; x += 20) {
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(x + i * 6, GROUND_Y + 30, 2, 6);
                }
            }
        }

        // ç”Ÿæˆæ–°éšœç¢ç‰©
        function spawnObstacle() {
            // éšæœºé—´éš”è·ç¦» (150-400åƒç´ )
            const randomInterval = (Math.floor(Math.random() * 2051) + 150)*((gameSpeed / BASE_GAME_SPEED-1)/5+1);

            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - randomInterval) {
                // æ¯æ¬¡åªç”Ÿæˆ1ä¸ªæ æ†
                // éšæœºå®½åº¦ (9-22.5åƒç´ ï¼Œæ‰©å¤§1.5å€)
                const width = Math.floor((Math.random() * 10 + 10) * 1.5);
                // éšæœºé«˜åº¦ (20-50åƒç´ )
                const height = Math.floor(Math.random() * 31) + 20;
                // æ æ†åº•éƒ¨ä¸åœ°é¢å¯¹é½
                const y = GROUND_Y + 32 - height;

                // éšæœºé€‰æ‹©éšœç¢ç‰©ç±»å‹ (0: æ æ†, 1: çŸ³å¤´, 2: å°æ ‘, 3: å°æˆ¿å­)
                const obstacleType = Math.floor(Math.random() * 4);

                obstacles.push({
                    x: canvas.width,
                    y: y,
                    width: width,
                    height: height,
                    type: obstacleType
                });
            }
        }

        // ç”Ÿæˆé“å…·
        function spawnPowerup() {
            // 30% æ¦‚ç‡ç”Ÿæˆé“å…·
            if (Math.random() < 0.05 && (powerups.length === 0 || powerups[powerups.length - 1].x < canvas.width - 200)) {
                const powerupType = Math.random() < 0.93 ? 'coin' : 'star'; // 90%é‡‘å¸ï¼Œ10%äº”è§’æ˜Ÿ
                // äº”è§’æ˜Ÿå¤§å°æ”¾å¤§ä¸€å€
                const size = powerupType === 'star' ? 32 : 16;
                const y = GROUND_Y - Math.random() * 100 - size; // åœ¨ç©ºä¸­éšæœºé«˜åº¦

                powerups.push({
                    x: canvas.width,
                    y: y,
                    width: size,
                    height: size,
                    type: powerupType
                });
            }
        }

        // æ›´æ–°æ¸¸æˆç‰©ç†
        function updatePhysics() {
            // è®¡ç®—å½“å‰é‡åŠ›ï¼ˆéšæ¸¸æˆé€Ÿåº¦å¢åŠ è€Œå¢åŠ ï¼Œä¿æŒè·³è·ƒé«˜åº¦ä¸å˜ä½†é€Ÿåº¦æ›´å¿«ï¼‰
            const speedMultiplier = gameSpeed / BASE_GAME_SPEED*1.2;
            const currentGravity = BASE_GRAVITY * speedMultiplier;

            // æ›´æ–°ç©å®¶ç‰©ç†ï¼ˆé‡åŠ›å’Œè·³è·ƒï¼‰
            if (player.isJumping || player.y < GROUND_Y) {
                player.velocityY += currentGravity; // åŠ¨æ€é‡åŠ›åŠ é€Ÿåº¦
                player.y += player.velocityY;

                // ç€åœ°æ£€æµ‹
                if (player.y >= GROUND_Y) {
                    player.y = GROUND_Y;
                    player.velocityY = 0;
                    player.isJumping = false;
                }
            }

            // æ›´æ–°éšœç¢ç‰©ä½ç½®
            obstacles.forEach((obstacle, index) => {
                obstacle.x -= gameSpeed;

                // ç§»é™¤å±å¹•å¤–çš„éšœç¢ç‰©å¹¶å¢åŠ åˆ†æ•°
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(index, 1);
                    score += 10;
                    scoreElement.textContent = `å¾—åˆ†: ${score}`;
                }
            });

            // æ›´æ–°é“å…·ä½ç½®
            powerups.forEach((powerup, index) => {
                powerup.x -= gameSpeed;

                // ç§»é™¤å±å¹•å¤–çš„é“å…·
                if (powerup.x + powerup.width < 0) {
                    powerups.splice(index, 1);
                }
            });

            // æ›´æ–°äº‘æœµä½ç½®
            clouds.forEach(cloud => {
                cloud.x -= cloud.speed;
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width + Math.random() * 100;
                    cloud.y = Math.random() * 100 + 20;
                }
            });

            // æ›´æ–°åœ°é¢æ»šåŠ¨
            groundOffset += gameSpeed;

            // æ›´æ–°æ— æ•ŒçŠ¶æ€
            if (invincible) {
                invincibleTime++;
                if (invincibleTime >= INVINCIBLE_DURATION) {
                    invincible = false;
                    invincibleTime = 0;
                }
            }

            // å¢åŠ æ¸¸æˆé€Ÿåº¦
            if (frameCount % 300 === 0) {
                gameSpeed += 0.05; // åŠ å¿«1.5å€ (0.2 * 1.5)
            }
        }

        // ç¢°æ’æ£€æµ‹ç³»ç»Ÿ
        function checkCollisions() {
            // æ£€æµ‹éšœç¢ç‰©ç¢°æ’ï¼ˆåªæœ‰åœ¨éæ— æ•ŒçŠ¶æ€ä¸‹æ‰ä¼šæ¸¸æˆç»“æŸï¼‰
            if (!invincible) {
                obstacles.forEach(obstacle => {
                    // AABBç¢°æ’æ£€æµ‹ç®—æ³•
                    if (player.x < obstacle.x + obstacle.width &&
                        player.x + player.width > obstacle.x &&
                        player.y < obstacle.y + obstacle.height &&
                        player.y + player.height > obstacle.y) {
                        gameOver();
                    }
                });
            }

            // æ£€æµ‹é“å…·ç¢°æ’
            powerups.forEach((powerup, index) => {
                let collisionX, collisionY, collisionWidth, collisionHeight;

                if (powerup.type === 'coin') {
                    // é‡‘å¸æ”¾å¤§2å€åçš„ç¢°æ’åŒºåŸŸ
                    collisionWidth = powerup.width * 2;
                    collisionHeight = powerup.height * 2;
                    collisionX = powerup.x - powerup.width / 2;
                    collisionY = powerup.y - powerup.height / 2;
                } else {
                    // å…¶ä»–é“å…·ä½¿ç”¨åŸæ¥çš„ç¢°æ’åŒºåŸŸ
                    collisionX = powerup.x;
                    collisionY = powerup.y;
                    collisionWidth = powerup.width;
                    collisionHeight = powerup.height;
                }

                if (player.x < collisionX + collisionWidth &&
                    player.x + player.width > collisionX &&
                    player.y < collisionY + collisionHeight &&
                    player.y + player.height > collisionY) {

                    // æ”¶é›†é“å…·
                    if (powerup.type === 'coin') {
                        score += 5; // é‡‘å¸å¢åŠ 50åˆ†
                        scoreElement.textContent = `å¾—åˆ†: ${score}`;
                    } else if (powerup.type === 'star') {
                        invincible = true;
                        invincibleTime = 0;
                    }

                    // ç§»é™¤å·²æ”¶é›†çš„é“å…·
                    powerups.splice(index, 1);
                }
            });
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            gameRunning = false;

            // æ£€æŸ¥æ˜¯å¦åˆ›é€ äº†æ–°çš„æœ€é«˜å¾—åˆ†
            const isNewRecord = checkHighScore();

            // ä¸Šä¼ åˆ†æ•°åˆ°MultiSYNQï¼ˆæ— è®ºæ˜¯å¦æ–°çºªå½•éƒ½ä¸Šä¼ ï¼‰
            uploadScoreToMultiSYNQ(currentPlayerName, score);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#FF4444';
            ctx.font = '48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('æ¸¸æˆç»“æŸ', canvas.width / 2, canvas.height / 2 - 60);

            // å¦‚æœåˆ›é€ äº†æ–°çºªå½•ï¼Œæ˜¾ç¤ºç‰¹æ®Šä¿¡æ¯
            if (isNewRecord) {
                ctx.fillStyle = '#FFD700';
                ctx.font = '28px Courier New';
                ctx.fillText('ğŸ‰ æ–°çºªå½•ï¼ğŸ‰', canvas.width / 2, canvas.height / 2 - 20);
            }

            ctx.fillStyle = '#FFFFFF';
            ctx.font = '24px Courier New';
            ctx.fillText(`æœ€ç»ˆå¾—åˆ†: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
            ctx.fillText(`ç©å®¶: ${currentPlayerName}`, canvas.width / 2, canvas.height / 2 + 50);
            ctx.fillText(`æœ€é«˜å¾—åˆ†: ${highScore}`, canvas.width / 2, canvas.height / 2 + 80);
            ctx.fillText('æŒ‰ R é”®é‡æ–°å¼€å§‹', canvas.width / 2, canvas.height / 2 + 110);
            ctx.textAlign = 'left';
        }

        // é‡ç½®æ¸¸æˆ
        function resetGame() {
            gameRunning = true;
            score = 0;
            gameSpeed = 3; // åŠ å¿«1.5å€ (2 * 1.5)
            frameCount = 0;
            groundOffset = 0;

            // é‡ç½®ç©å®¶çŠ¶æ€
            player.y = GROUND_Y;
            player.velocityY = 0;
            player.isJumping = false;

            // æ¸…ç©ºéšœç¢ç‰©å’Œé“å…·
            obstacles = [];
            powerups = [];

            // é‡ç½®æ— æ•ŒçŠ¶æ€
            invincible = false;
            invincibleTime = 0;

            // é‡æ–°åˆå§‹åŒ–äº‘æœµ
            clouds = [];
            initClouds();

            // é‡ç½®æ¸¸æˆçŠ¶æ€ä¸Šä¼ 
            resetGameStateUpload();

            scoreElement.textContent = `å¾—åˆ†: ${score}`;
        }

        // ç©å®¶è·³è·ƒ
        function jump() {
            if (!player.isJumping && player.y === GROUND_Y) {
                // è·³è·ƒåŠ›åº¦ä¹Ÿéšæ¸¸æˆé€Ÿåº¦å¢åŠ ï¼Œä¿æŒè·³è·ƒé«˜åº¦ä¸å˜
                const speedMultiplier = gameSpeed / BASE_GAME_SPEED;
                const adjustedJumpForce = JUMP_FORCE * speedMultiplier*1.1;
                player.velocityY = adjustedJumpForce; // åŠ¨æ€è·³è·ƒåˆå§‹é€Ÿåº¦
                player.isJumping = true;
            }
        }

        // ä¸»æ¸¸æˆå¾ªç¯
        function gameLoop() {
            if (gameRunning) {
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶èƒŒæ™¯æ¸å˜
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.7, '#98FB98');
                gradient.addColorStop(1, '#228B22');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶æ¸¸æˆå…ƒç´ 
                drawClouds();
                drawGround();
                drawPowerups();
                drawPlayer();
                drawObstacles();

                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                updatePhysics();
                spawnObstacle();
                spawnPowerup();
                checkCollisions();

                // ä¸Šä¼ æ¸¸æˆçŠ¶æ€åˆ°MultiSYNQï¼ˆå®æ—¶æ•°æ®åˆ†äº«ï¼‰
                uploadGameStateToMultiSYNQ();

                frameCount++;
            }

            requestAnimationFrame(gameLoop);
        }

        // é”®ç›˜äº‹ä»¶ç›‘å¬
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'Space':
                    event.preventDefault();
                    if (gameRunning) {
                        jump();
                    }
                    break;
                case 'KeyR':
                    event.preventDefault();
                    resetGame();
                    break;
            }
        });

        // é˜²æ­¢ç©ºæ ¼é”®æ»šåŠ¨é¡µé¢
        document.addEventListener('keypress', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
            }
        });

        // æ¸¸æˆåˆå§‹åŒ–
        async function initGame() {
            loadPlayerImage(); // åŠ è½½ç©å®¶å›¾ç‰‡
            loadCoinImage(); // åŠ è½½é‡‘å¸å›¾ç‰‡
            loadHighScore(); // åŠ è½½æœ€é«˜å¾—åˆ†
            initClouds();
            resetGame();

            // åˆå§‹åŒ–ç©å®¶ä¿¡æ¯æ˜¾ç¤º
            updatePlayerInfoDisplay();

            // æ¸…ç†æœ¬åœ°å­˜å‚¨å¹¶æ˜¾ç¤ºç©ºæ’è¡Œæ¦œ
            clearLocalStorage();
            showEmptyLeaderboard();

            // åˆå§‹åŒ–MultiSYNQè¿æ¥
            await initMultiSYNQ();

            gameLoop();
        }

        // æ¸…é™¤æ‰€æœ‰MultiSYNQæ•°æ®
        function clearAllData() {
            // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
            const confirmed = confirm(
                "âš ï¸ ç¡®å®šè¦æ¸…é™¤MultiSYNQä¸Šçš„æ‰€æœ‰æ•°æ®å—ï¼Ÿ\n\nè¿™å°†æ¸…é™¤ï¼š\n" +
                "â€¢ æ‰€æœ‰ç©å®¶çš„æ’è¡Œæ¦œè®°å½•\n" +
                "â€¢ æ‰€æœ‰ç©å®¶çš„æ¸¸æˆçŠ¶æ€æ•°æ®\n" +
                "â€¢ æ•´ä¸ªMultiSYNQä¼šè¯çš„æ•°æ®\n\n" +
                "âš ï¸ æ³¨æ„ï¼šè¿™ä¼šå½±å“æ‰€æœ‰è¿æ¥çš„ç©å®¶ï¼\n" +
                "æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼"
            );

            if (!confirmed) {
                return;
            }

            console.log("ğŸ—‘ï¸ Starting to clear all MultiSYNQ data...");

            if (!isConnected || !multisynqSession || !multisynqSession.view) {
                alert("âŒ æœªè¿æ¥åˆ°MultiSYNQï¼Œæ— æ³•æ¸…é™¤æ•°æ®ï¼\nè¯·å…ˆè¿æ¥åˆ°MultiSYNQã€‚");
                return;
            }

            try {
                // é€šè¿‡MultiSYNQ Modelæ¸…é™¤æ‰€æœ‰æ•°æ®
                console.log("ğŸ“¡ Sending clear all data request to MultiSYNQ...");

                // å‘é€æ¸…é™¤æ‰€æœ‰æ•°æ®çš„äº‹ä»¶ç»™Model
                multisynqSession.view.publish(multisynqSession.view.model.sessionId, "clear-all-data", {
                    timestamp: Date.now(),
                    requestedBy: currentPlayerName,
                    action: "clear-all-multisynq-data"
                });

                console.log("âœ… Clear data request sent to MultiSYNQ");

                // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                alert("ğŸ‰ æ¸…é™¤è¯·æ±‚å·²å‘é€ï¼\n\næ‰€æœ‰MultiSYNQæ•°æ®å°†è¢«æ¸…é™¤ã€‚\nè¯·ç­‰å¾…å‡ ç§’é’Ÿååˆ·æ–°é¡µé¢æŸ¥çœ‹æ•ˆæœã€‚");

                // å»¶è¿Ÿåè‡ªåŠ¨åˆ·æ–°é¡µé¢
                setTimeout(() => {
                    if (confirm("æ•°æ®æ¸…é™¤å®Œæˆï¼æ˜¯å¦åˆ·æ–°é¡µé¢æŸ¥çœ‹æ•ˆæœï¼Ÿ")) {
                        location.reload();
                    }
                }, 3000);

            } catch (error) {
                console.error("âŒ Error clearing MultiSYNQ data:", error);
                alert("âŒ æ¸…é™¤MultiSYNQæ•°æ®æ—¶å‘ç”Ÿé”™è¯¯ï¼š" + error.message);
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        initGame();
    </script>
</body>

</html>